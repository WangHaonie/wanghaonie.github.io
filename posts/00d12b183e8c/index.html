

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=dark>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="WangHaonie">
  <meta name="keywords" content="">
  
    <meta name="description" content="文章较长，请耐心阅读~  前言如果你不喜欢 WinForms 仅仅是因为它不支持深色主题的话，那一定要看看这篇文章。要注意的是：  最新版 .NET 貌似已经支持深色模式，但本文只针对低版本 .NET； 推荐有一定 Win32&amp;#x2F;C++ 编程经验的朋友们阅读，没有也没关系，我会尽量用通俗的语句来讲解，很简单的； 原生深色主题作用范围有限 (毕竟不是公开的)，不能达到 100% 覆盖，且仅支">
  
  
  
  <title>从零开始让你的 WinForms 应用程序也用上原生深色主题 | WangHaonie 的博客</title>
  <link rel="stylesheet" href="/css/frosted.css">
  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"wanghaonie.github.io","root":"/","version":"1.9.6","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":true,"scope":"home"},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":6},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":"G-N644FC8JLJ"},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=G-N644FC8JLJ", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', 'G-N644FC8JLJ');
        });
      }
    </script>
  

  

  

  

  



  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>WangHaonie 的博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <span id="wanghaonie-nav" candidate-icon="🧿🔔📅🚩🧡">🎉更多</span>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                
                <span>🏠主页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                
                <span>😁关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                
                <span>🏷️标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                
                <span>📖文章</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button"
                 data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                
                <span>🌏分站</span>
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" onclick="redir2gh()" href="#" target="_self">
                    
                    <span>🌎主站：GitHub Pages</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" onclick="redir2lan()" href="#" target="_self">
                    
                    <span>🌎主站：本地局域网</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" onclick="redir2v()" href="#" target="_self">
                    
                    <span>🌎分站：Vercel</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" onclick="redir2n()" href="#" target="_self">
                    
                    <span>🌎分站：Netlify</span>
                  </a>
                
              </div>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/reward" target="_self">
                
                <span>💰打赏</span>
              </a>
            </li>
          
        <!--
        -->
        <!--
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        -->
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" false
     style="background: url('/null') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">从零开始让你的 WinForms 应用程序也用上原生深色主题</span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-07-23 08:31" pubdate>
          2025-07-23 08:31:03
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          11k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          96 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">从零开始让你的 WinForms 应用程序也用上原生深色主题</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：1 小时前
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <p class="note note-danger">文章较长，请耐心阅读~</p>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果你不喜欢 WinForms 仅仅是因为它不支持深色主题的话，那一定要看看这篇文章。要注意的是：</p>
<ul>
<li>最新版 .NET 貌似已经支持深色模式，但本文只针对低版本 .NET；</li>
<li>推荐有一定 Win32&#x2F;C++ 编程经验的朋友们阅读，没有也没关系，我会尽量用通俗的语句来讲解，很简单的；</li>
<li>原生深色主题作用范围有限 (毕竟不是公开的)，不能达到 100% 覆盖，且仅支持 <strong>Windows 10 1903 及以上</strong> 系统。本文将对以下类型的控件的深色主题进行讨论，其他控件请自行尝试 <strong>套用类似的方法</strong> 或者 <strong>查阅相关资料</strong> 或者 <strong>直接使用第三方 UI 库</strong> 或者 <strong>转向 WPF</strong> 或者 <strong>放弃</strong>。😅</li>
<li>理论上来说深色主题支持热重载，即在运行时开启或关闭深色主题。但我不推荐，我采用的是用户更改主题时询问是否重启应用程序。若你有需求也可以尝试一下。</li>
<li>以下所有详细实现都能在 <a target="_blank" rel="noopener" href="https://github.com/WangHaonie/PlainCEETimer">PlainCEETimer</a> 中找到。</li>
</ul>
<h2 id="支持的控件"><a href="#支持的控件" class="headerlink" title="支持的控件"></a>支持的控件</h2><h3 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h3><p>修改 <code>ForeColor</code> 和 <code>BackColor</code> 属性就能实现。</p>
<ul>
<li>Form (除标题栏以外)</li>
<li>Panel</li>
<li>GroupBox (除标题以外)</li>
<li>Label (跟随父容器自动适应)</li>
<li>LinkLabel (跟随父容器自动适应)</li>
<li>PictureBox (跟随父容器自动适应)</li>
</ul>
<h3 id="原生支持"><a href="#原生支持" class="headerlink" title="原生支持"></a>原生支持</h3><p>调用 Win32 API 即可实现。</p>
<ul>
<li>Form (标题栏)</li>
<li>ContextMenu</li>
<li>Button</li>
<li>TextBox</li>
<li>CheckBox</li>
<li>RadioButton</li>
<li>ComboBox</li>
<li>TreeView</li>
<li>NumericUpDown</li>
<li>ListView (初步)</li>
<li><del>TabControl</del> (改用 TreeView)</li>
<li><del>ContextMenuStrip</del> (改用 ContextMenu)</li>
</ul>
<h3 id="自绘实现"><a href="#自绘实现" class="headerlink" title="自绘实现"></a>自绘实现</h3><p>重写 <code>OnPaint</code> 等方法才能实现</p>
<ul>
<li>GroupBox</li>
</ul>
<h3 id="Hook-实现"><a href="#Hook-实现" class="headerlink" title="Hook 实现"></a>Hook 实现</h3><ul>
<li>重写 <code>HookProc</code> 拦截相关消息即可实现<ul>
<li>ColorDialog</li>
<li>FontDialog</li>
</ul>
</li>
<li>子类化即可实现<ul>
<li>ListView (完整)</li>
</ul>
</li>
<li>需要借助 IAT Hook 才能实现<ul>
<li>ScrollBar</li>
</ul>
</li>
</ul>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="窗口句柄"><a href="#窗口句柄" class="headerlink" title="窗口句柄"></a>窗口句柄</h3><p>窗口句柄 (hWnd, Handle of Window)，可以理解为窗口&#x2F;控件的唯一标识符。在 Win32 中，所有的控件和窗口在创建时都会被分配一个全新的 HWND，有了它我们基本上就可以完全控制所属控件了。它在 Win32 中类型为 HWND，在 C# WinForms 中对应实现了 IWin32Window 的对象的 Handle 属性，类型为 IntPtr。</p>
<p>另外，在 Win32 中 控件即窗口，窗口即控件，两者概念几乎相同。这也就是为什么 WinForms 里 Form 和其他大多数控件都继承自 Control，因为 WinForms 本质就是对 Win32 的封装 (类似于 MFC)，架构什么的肯定要与 Win32 一致。</p>
<p class="note note-info"><strong>你知道吗？</strong><br>个别软件 (比如 System Informer) 提供了很神金的功能。这个软件具有枚举应用程序所有窗口/控件的功能，并且还提供了很多 侵入式 的选项，比如销毁、隐藏窗口/控件等，这都还能李姐。最离谱的是还有最小化、最大化等本应该用在窗口的功能，现在也可以应用一切在具有 HWND 的对象上。也就是说，你可以通过此功能对控件进行最小化、最大化。这也更加印证了 Win32 里窗口和控件的概念是相似的，你甚至可以直接说 Win32 里只有窗口，没有控件。</p>

<h3 id="消息循环"><a href="#消息循环" class="headerlink" title="消息循环"></a>消息循环</h3><p>消息循环是 Win32 应用程序的核心，一个应用程序一般只有一个消息循环。有了它，应用程序的窗口才能获取系统、用户对它的指示，从而做出相应的回应。</p>
<p class="note note-info"><strong>你知道吗？</strong><br>当在应用程序内打开一个模态 (Modal) 对话框时，会额外启动一个临时的消息循环，会在模态对话框关闭时结束这个消息循环。如果是 WinForms 的话，可以通过 <code>Form.ShowDialog()</code> 打开一个模态对话框。我们通过一些手段，发现在正式运行对话框之前，WinForms 内部先调用 <code>Application.BeginModalMessageLoop()</code> 或类似方法启动模态消息循环，并在对话框关闭后调用 <code>Application.EndModalMessageLoop()</code> 或类似方法结束此消息循环。这样做的目的就是防止用户打开模态对话框的同时操作应用程序其他窗口，这也就是为什么我们无法在通过 <code>ShowDialog()</code> 打开的窗体的外面操作其他窗体。</p>

<p>消息的载体在 Win32 和 WinForms 中被定义为 MSG&#x2F;Message 类型，它是一种结构体 (struct)，主要字段有：</p>
<table>
<thead>
<tr>
<th>Win32 声明</th>
<th>WinForms 声明</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>HWND hwnd</td>
<td>IntPtr HWnd</td>
<td>消息接收方的句柄</td>
</tr>
<tr>
<td>UINT message</td>
<td>int Msg</td>
<td>消息编号，区分是什么消息</td>
</tr>
<tr>
<td>WPARAM wParam</td>
<td>IntPtr WParam</td>
<td>可大致理解为附加的小型数据</td>
</tr>
<tr>
<td>LPARAM lParam</td>
<td>IntPtr LParam</td>
<td>可大致理解为附加的大型数据</td>
</tr>
</tbody></table>
<p>你可能注意到 消息编号 在 Win32 是 UINT (C# 里也有 uint)，在 WinForms 里是 int，难道不会出错吗？</p>
<p>这个问题我只能说 Win32 里多半又是什么历史遗留下来的原因，才用 UINT。但可以肯定的是，Win32 使用的消息，范围都不会超出 int 的最大值，而在 C# 中 int 又是很常用的类型，所以就理所当然的变成了 int，也不用担心会溢出。</p>
<h3 id="窗口过程"><a href="#窗口过程" class="headerlink" title="窗口过程"></a>窗口过程</h3><p>窗口过程 (WndProc, Window Procedure)，就是该窗口用于处理消息的 “工厂”，在 Win32 里对应 WNDPROC，它一般长这个样子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">LRESULT CALLBACK <span class="hljs-title">WndProc</span><span class="hljs-params">(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">switch</span> (uMsg)<br>    &#123;<br>        <span class="hljs-keyword">case</span> WM_CREATE:<br>            <span class="hljs-comment">// 准备创建窗口</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 表示已被处理</span><br><br>        <span class="hljs-comment">// 其他消息</span><br><br>        <span class="hljs-keyword">case</span> WM_DESTROY:<br>            <span class="hljs-comment">// 窗口已销毁</span><br>            <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 跳出 switch，走外面的语句</span><br><br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">DefWindowProc</span>(hWnd, uMsg, wParam, lParam); <span class="hljs-comment">// 让默认的消息函数处理上方未处理的消息</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 被 break 跳到这里</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在 WinForms 里，它长这个样子：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WndProc</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> Message m</span>)</span><br>&#123;<br>    <span class="hljs-keyword">switch</span> (m.Msg)<br>    &#123;<br>        <span class="hljs-keyword">case</span> WM_CREATE:<br>            <span class="hljs-comment">// 准备创建窗口</span><br>            m.Result = IntPtr.Zero; <span class="hljs-comment">// 表示已被处理</span><br>            <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-comment">// 其他消息</span><br><br>        <span class="hljs-keyword">case</span> WM_DESTROY:<br>            <span class="hljs-comment">// 窗口已销毁</span><br>            <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 跳出 switch，走外面的语句</span><br><br>        <span class="hljs-literal">default</span>:<br>            m.Result = DefWindowProc(hWnd, uMsg, wParam, lParam); <span class="hljs-comment">// 让默认的消息函数处理上方未处理的消息</span><br>            <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    m.Result = IntPtr.Zero; <span class="hljs-comment">// 被 break 跳到这里</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>可见尽管两者的函数签名不同，但内部都干着同样的事，当然以上代码仅供参考，实际会比这更复杂。</p>
<p class="note note-info"><strong>你知道吗？</strong><br>随着现代 UI 技术的发展，很多软件已经不再使用 Win32/MFC/WinForms 这种套路来创建控件了，而是使用性能更好、外观更优雅的 UI 框架，比如 Material、Flutter、Electron、Tauri、Qt、WinUI、Avalonia 等。原因可能有：<br>&nbsp;&nbsp;&nbsp;&nbsp;1. <strong>Win32 太丑了</strong>。但我觉得还好，我甚至认为有些现代 UI 框架还不如 Win32。<br>&nbsp;&nbsp;&nbsp;&nbsp;2. <strong>需要更高级的动画和 UX</strong>。Win32 是基于 GDI/GDI+ 的，也就是 CPU 渲染，但大多数情况下并不会遇到性能瓶颈，除非在需要渲染大量内容，才会出现各种忍无可忍的闪烁卡顿。而现代 UI 框架完美地解决了这一点，因为它们使用了 DirectX 渲染，也就是利用了 GPU 进行界面绘制。Win32 的动画由系统提供，虽然不如现代 UI 库那样更精美丝滑，但也还算看得过去。<br>&nbsp;&nbsp;&nbsp;&nbsp;3. <strong>跨平台支持</strong>。可悲的是，Win32 写的应用程序只能运行在 Windows 系统中，跨平台性直接无了。而现代 UI (比如 Avalonia) 完美的解决了这一问题，它们提倡 UI 与业务逻辑分离，让开发者不再担心 UI 的跨平台性，一套代码就能走遍天下所有平台系统。<br><br>如果你选择现代 UI 框架，需要知道：<br>&nbsp;&nbsp;&nbsp;&nbsp;1. <strong>控件就是控件，窗口就是窗口</strong>。现代 UI 框架消除了 Win32 中 控件即窗口，窗口即控件 的概念，也就是说现在一个窗口及内部总共就只有一个 WndProc，控件全部由所属窗口画上去的。但不变的是本质，毕竟 Windows 本身就是基于消息循环的，即便是再现代的 UI，只要运行在 Windows 上，是不会完全脱离消息循环的。<br>&nbsp;&nbsp;&nbsp;&nbsp;2. <strong>较大的体积和较高的内存占用</strong>。UI 框架本身也要消耗一定的性能。因为要重新设计几乎所有消息循环干的事情，以及自身的各种界面、动画、资源等，这无论是应用程序体积，还是运行时内存占用，都比 Win32 高上一个层次。但随着个人电脑的内存越来大，性能越来越高，多个几十百兆其实也不在话下。</p>

<h3 id="钩子过程"><a href="#钩子过程" class="headerlink" title="钩子过程"></a>钩子过程</h3><p>钩子过程 (HookProc, Hook Procedure，也叫挂钩过程) 有两种含义，一是通过 SetWindowsHookEx 函数设置的全局钩子，二是 Common Dialogs 的 ColorDialog、FontDialog (CHOOSECOLOR、CHOOSEFONT) 提供的一个私有的类似于 WndProc 的东西，仅供自己使用，用于添加一些自定义的功能，与前者是两个不同的概念。本文主要讨论后者。</p>
<p>在 WinForms 里，它通常长这个样子，非常类似于 Win32 的 WndProc：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> IntPtr <span class="hljs-title">HookProc</span>(<span class="hljs-params">IntPtr hWnd, <span class="hljs-built_in">int</span> msg, IntPtr wparam, IntPtr lparam</span>)</span><br>&#123;<br>    <span class="hljs-keyword">switch</span> (msg)<br>	&#123;<br>        <span class="hljs-comment">// ... 处理各消息</span><br>	&#125;<br><br>	<span class="hljs-keyword">return</span> IntPtr.Zero; <span class="hljs-comment">// 钩子过程最后一般都返回 0</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="子类化"><a href="#子类化" class="headerlink" title="子类化"></a>子类化</h3><p>子类化 (Subclassing) 的作用有点类似于钩子，只不过它多用于钩住窗口中的子控件。只有在通常用于无法通过常规手段更改控件样式或行为时使用。</p>
<p>因为上面说了，每个控件&#x2F;窗口都有一个独立的 WndProc，而我们在窗口中处理控件样式&#x2F;行为时只能获取到本窗体的 WndProc，虽然能收到一些发送给控件的消息，但有关绘制的消息就必须拦截控件自己的 WndProc，所以 子类化 就相当于在窗口中监听所有系统发送给控件的消息 (因为系统给控件发送消息基本不会经过所在窗体的 WndProc)，从而进行更多自定义的功能。</p>
<p>在 Win32 中，我们通常使用 CommCtrl.h 提供的 SetWindowSubclass 和 RemoveWindowSubclass 来对窗体进行&#x2F;移除子类化。</p>
<p>但在 WinForms 中，我们不需要导入这两个函数来子类化，.NET 为我们提供了类似子类化的功能，叫 NativeWindow 类。它继承自 Component，是对 Win32 窗口的低级封装 (只提供 WndProc，不提供或提供少量其他功能就叫低级封装)，也就是传入 句柄 给 NativeWindow，我们相当于获取到了目标窗口的实例，而这个类也提供了 WndProc 虚方法，可供我们重写，来达到子类化的效果。</p>
<h3 id="调用约定"><a href="#调用约定" class="headerlink" title="调用约定"></a>调用约定</h3><p>调用约定 (CallingConvention)，就是调用本机函数的方式 (好比你上网的方式，WiFi，移动数据等。简单知道有这么个东西就行了，不用纠结有什么区别，保持约定一致就行)。WinAPI 默认就是 StdCall，C# 里 Interop 的 [DllImport] 默认也是 StdCall，后面我们导出函数也要声明为 StdCall。</p>
<h3 id="封送"><a href="#封送" class="headerlink" title="封送"></a>封送</h3><p>封送 (Marshaling)，指从非托管环境 (Unmanaged，即 Win32) 中将对象转换为托管环境 (Managed，即 C#) 对象的过程，以及反向转换的过程。常见的就是将返回值为 Win32 BOOL 的函数转换为 C# bool，一般这么写：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">return: MarshalAs(UnmanagedType.Bool)</span>]<br></code></pre></td></tr></table></figure>
<p class="note note-info"><strong>你知道吗？</strong><br>BOOL 类型实际上是 int，也就是我们可以直接将 BOOL 返回类型的函数声明为 int，这样就可以不用添加 MarshalAs 了，但当我们需要判断真假的时候就有点麻烦了，由于没有 CLR 帮我们封送为 bool，我们在判断的时候需要手动书写 <code>!= 0</code>(true)，和 <code>== 0</code>(false)，通常不推荐这么做。</p>

<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="安装-C"><a href="#安装-C" class="headerlink" title="安装 C++"></a>安装 C++</h3><p>某些 Interop，我们交给 C++ 会更好，用 C# 的话过于麻烦甚至无法完成。所以需要用到 C++。</p>
<p class="note note-warning">不要觉得难以维护什么的，毕竟需要同时编写 C# 和 C++。要知道 工欲善其事，必先利其器，这些都是写好一个软件的关键，有助于增强用户体验的我们怎么能不做呢？Visual Studio 里一个解决方案多个项目的也不少见，一个程序由多个语言配合完成的例子就更多了。</p>

<p>首先关闭 Visual Studio，打开 Visual Studio Installer，点击 修改。在弹出的页面中勾选 使用 C++ 的桌面开发</p>
<p><img src="/archive-imgs/38/34-vs-inst-cpp.png" srcset="/img/loading.gif" lazyload></p>
<p>在右侧按图示勾选或取消勾选相应的组件，之后点击右下角修改，开始安装</p>
<p><img src="/archive-imgs/38/35-vs-inst-cpp-select.png" srcset="/img/loading.gif" lazyload></p>
<p>安装完成后，打开 C# 项目，右键<strong>解决方案</strong>，选择 添加 &gt;新项目</p>
<p><img src="/archive-imgs/38/2-create-cpp-dll-pre.png" srcset="/img/loading.gif" lazyload></p>
<p>找到 动态链接库 (C++)</p>
<p><img src="/archive-imgs/38/2-create-cpp-dll.png" srcset="/img/loading.gif" lazyload></p>
<p>命名为 <code>MyApp.Natives</code> 然后创建就行了，这样我们的解决方案里就有两个项目了。</p>
<p><img src="/archive-imgs/38/3-cs-cpp-proj.png" srcset="/img/loading.gif" lazyload></p>
<p>接着把 C++ 项目设置为 C# 的依赖项，可以使我们编译 C# 时，先编译 C++：右键 C# 项目，选择 构建依赖 &gt;项目依赖<br><img src="/archive-imgs/38/4-assoc-cs-to-cpp.png" srcset="/img/loading.gif" lazyload></p>
<p>把 C++ 项目勾选上<br><img src="/archive-imgs/38/5-assoc-cs-to-cpp-dep.png" srcset="/img/loading.gif" lazyload></p>
<p>当然这也要求两个项目的输出目录是一样的，这里我就只设置 C++ 了，因为 C# 的设置过了。右键 C++ 项目选择属性，第一个页面就是<br><img src="/archive-imgs/38/6-set-cpp-out-dir.png" srcset="/img/loading.gif" lazyload></p>
<p>为了后面编译 C++ 不会错误，我们先设置链接器。</p>
<p>右键 C++ 项目选择属性 &gt;链接器 &gt;输入 &gt;编辑</p>
<p><img src="/archive-imgs/38/7-cpp-linker.png" srcset="/img/loading.gif" lazyload></p>
<p>填入这三个静态链接库，注意不要删除自带的那两个，最后点击保存</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">uxtheme.lib<br>comctl32.lib<br>ucrt.lib<br></code></pre></td></tr></table></figure>

<p><img src="/archive-imgs/38/8-edit-cpp-linker.png" srcset="/img/loading.gif" lazyload></p>
<p>然后找到这个 dllmain.cpp，右键把它删除，因为我们主要用于导出函数供 C# 调用，不需要指定入口</p>
<p><img src="/archive-imgs/38/17-del-cppdll-main.png" srcset="/img/loading.gif" lazyload></p>
<p>接着打开 pch.h，我们添加一个宏定义，方便我们导出调用约定为 StdCall 的函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> cexport(type) extern <span class="hljs-string">&quot;C&quot;</span> __declspec(dllexport) type WINAPI</span><br></code></pre></td></tr></table></figure>

<p><img src="/archive-imgs/38/18-add-cpp-export-macro.png" srcset="/img/loading.gif" lazyload></p>
<p>大概就先这样，留着后面要用。</p>
<h3 id="C-版本"><a href="#C-版本" class="headerlink" title="C# 版本"></a>C# 版本</h3><p>由于面向 .NET Framework 4.8 或其他版本，且本文部分代码使用新特性写着比较舒服，建议将 C# 版本升级到 preview。</p>
<p>VSCode 或记事本打开项目文件 <code>XXX.csproj</code>，更改以下内容：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Project</span> <span class="hljs-attr">ToolsVersion</span>=<span class="hljs-string">&quot;15.0&quot;</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Import</span> <span class="hljs-attr">Project</span>=<span class="hljs-string">&quot;$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props&quot;</span> <span class="hljs-attr">Condition</span>=<span class="hljs-string">&quot;Exists(&#x27;$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props&#x27;)&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">PropertyGroup</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">LangVersion</span>&gt;</span>preview<span class="hljs-tag">&lt;/<span class="hljs-name">LangVersion</span>&gt;</span> <span class="hljs-comment">&lt;!-- 新建一个 PropertyGroup 加入这行 --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">PropertyGroup</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- ... --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">PropertyGroup</span> <span class="hljs-attr">Condition</span>=<span class="hljs-string">&quot;&#x27;$(Configuration)|$(Platform)&#x27; == &#x27;Debug|x64&#x27;&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- ... --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">LangVersion</span>&gt;</span>7.3<span class="hljs-tag">&lt;/<span class="hljs-name">LangVersion</span>&gt;</span> <span class="hljs-comment">&lt;!-- 若有，删除这行 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- ... --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">PropertyGroup</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">PropertyGroup</span> <span class="hljs-attr">Condition</span>=<span class="hljs-string">&quot;&#x27;$(Configuration)|$(Platform)&#x27; == &#x27;Release|x64&#x27;&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- ... --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">LangVersion</span>&gt;</span>7.3<span class="hljs-tag">&lt;/<span class="hljs-name">LangVersion</span>&gt;</span> <span class="hljs-comment">&lt;!-- 若有，删除这行 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- ... --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">PropertyGroup</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- ... --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Project</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="应用程序清单文件"><a href="#应用程序清单文件" class="headerlink" title="应用程序清单文件"></a>应用程序清单文件</h3><p>用于确保我们可以正确获取到当前系统版本 (微软的吊特性)，可以在 Visual Studio 右键 C# 项目的 Properties 文件夹，点击添加，选择 <code>应用程序清单 (仅 Windows)</code>。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">assembly</span> <span class="hljs-attr">manifestVersion</span>=<span class="hljs-string">&quot;1.0&quot;</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;urn:schemas-microsoft-com:asm.v1&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">assemblyIdentity</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;1.0.0.0&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;MyApplication.app&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">compatibility</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;urn:schemas-microsoft-com:compatibility.v1&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">application</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">supportedOS</span> <span class="hljs-attr">Id</span>=<span class="hljs-string">&quot;&#123;35138b9a-5d96-4fbd-8e2d-a2440225f93a&#125;&quot;</span> /&gt;</span> <span class="hljs-comment">&lt;!-- 表示支持 Windows 7 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">supportedOS</span> <span class="hljs-attr">Id</span>=<span class="hljs-string">&quot;&#123;4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38&#125;&quot;</span> /&gt;</span> <span class="hljs-comment">&lt;!-- 表示支持 Windows 8 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">supportedOS</span> <span class="hljs-attr">Id</span>=<span class="hljs-string">&quot;&#123;1f676c76-80e1-4239-95bb-83d0f6d0da78&#125;&quot;</span> /&gt;</span> <span class="hljs-comment">&lt;!-- 表示支持 Windows 8.1 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">supportedOS</span> <span class="hljs-attr">Id</span>=<span class="hljs-string">&quot;&#123;8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a&#125;&quot;</span> /&gt;</span> <span class="hljs-comment">&lt;!-- 表示支持 Windows 10/11 --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">compatibility</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">application</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;urn:schemas-microsoft-com:asm.v3&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">windowsSettings</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dpiAware</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/SMI/2005/WindowsSettings&quot;</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">dpiAware</span>&gt;</span> <span class="hljs-comment">&lt;!-- 不想支持高 DPI 的话可以删除这段 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">longPathAware</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/SMI/2016/WindowsSettings&quot;</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">longPathAware</span>&gt;</span> <span class="hljs-comment">&lt;!-- 这是启用 Windows 的路径过长感知，保持默认即可 --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">windowsSettings</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">assembly</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="代码布局"><a href="#代码布局" class="headerlink" title="代码布局"></a>代码布局</h3><p>推荐将所有有关主题的代码放在一个单独的静态类里，比如 ThemeManager：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ThemeManager</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> CanUseDarkTheme &#123; <span class="hljs-keyword">get</span>; <span class="hljs-comment">/* private set; */</span> &#125; <span class="hljs-comment">// 指示是否要用深色主题</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Color DarkFore &#123; <span class="hljs-keyword">get</span>; &#125; = Color.White; <span class="hljs-comment">// 文字颜色</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Color DarkForeLink &#123; <span class="hljs-keyword">get</span>; &#125; = Color.FromArgb(<span class="hljs-number">153</span>, <span class="hljs-number">235</span>, <span class="hljs-number">255</span>); <span class="hljs-comment">// 超链接颜色</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Color DarkBack &#123; <span class="hljs-keyword">get</span>; &#125; = Color.FromArgb(<span class="hljs-number">32</span>, <span class="hljs-number">32</span>, <span class="hljs-number">32</span>); <span class="hljs-comment">// 背景颜色</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Color DarkBorder &#123; <span class="hljs-keyword">get</span>; &#125; = Color.FromArgb(<span class="hljs-number">60</span>, <span class="hljs-number">60</span>, <span class="hljs-number">60</span>); <span class="hljs-comment">// 边框颜色</span><br><br>    <span class="hljs-comment">// 系统构建号，用于版本判断</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> OSBuild =&gt; field == <span class="hljs-number">0</span> ? field = Environment.OSVersion.Version.Build : field; <span class="hljs-comment">// 获取当前系统版本的构建号</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> Windows10_1903 = <span class="hljs-number">18362</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> Windows10_20H1 = <span class="hljs-number">18985</span>;<br><br>    <span class="hljs-comment">// 一些 WinAPI Interop，后面会介绍</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>窗体&#x2F;控件的话最好单独继承出来，方便复用各自的主题：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyFormBase</span> : <span class="hljs-title">Form</span><br>&#123;<br>    <span class="hljs-comment">// 让你应用程序所有窗体继承自 MyFormBase</span><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-comment">/* sealed */</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyButton</span> : <span class="hljs-title">Button</span> <span class="hljs-comment">// 其他控件也是，可选是否密封 sealed</span><br>&#123;<br>    <span class="hljs-comment">// 之后直接使用自己封装的 MyButton 而不是 .NET 的</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>下面我们就正式开始挨个对控件应用深色主题了。</p>
<h3 id="Form"><a href="#Form" class="headerlink" title="Form"></a>Form</h3><p>窗体的深色主题非常简单，只需要设置 ForeColor、BackColor 就行了：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyFormBase</span> : <span class="hljs-title">Form</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyFormBase</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (ThemeManager.CanUseDarkTheme)<br>        &#123;<br>            ForeColor = ThemeManager.DarkFore;<br>            BackColor = ThemeManager.DarkBack;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Form1</span> : <span class="hljs-title">MyFormBase</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Form1</span>()</span><br>    &#123;<br>        InitializeComponent();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>此时编译并打开 Form1，你会发现窗体标题栏没有变黑，这是因为 Form，即窗口，由系统管理，.NET 管不到，所以要引入 WinAPI。</p>
<p>转到 ThemeManager，添加以下代码：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> DWMWA_USE_IMMERSIVE_DARK_MODE_BEFORE_20H1 = <span class="hljs-number">19</span>; <span class="hljs-comment">// ≥ 1903 且 ≤ 20H1</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> DWMWA_USE_IMMERSIVE_DARK_MODE = <span class="hljs-number">20</span>; <span class="hljs-comment">// 20H1 之后</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">FlushWindow</span>(<span class="hljs-params">IntPtr hWnd</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (OSBuild &gt;= Windows10_1903)<br>    &#123;<br>        <span class="hljs-keyword">var</span> type = OSBuild &gt;= Windows10_20H1 ? DWMWA_USE_IMMERSIVE_DARK_MODE : DWMWA_USE_IMMERSIVE_DARK_MODE_BEFORE_20H1;<br>        <span class="hljs-keyword">var</span> enable = <span class="hljs-number">1</span>; <span class="hljs-comment">// 1 表示启用，0 禁用</span><br>        DwmSetWindowAttribute(hWnd, type, <span class="hljs-keyword">ref</span> enable, <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">int</span>));<br>    &#125;<br>&#125;<br><br>[<span class="hljs-meta">DllImport(<span class="hljs-string">&quot;dwmapi.dll&quot;</span>)</span>]<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">extern</span> <span class="hljs-built_in">int</span> <span class="hljs-title">DwmSetWindowAttribute</span>(<span class="hljs-params">IntPtr hWnd, <span class="hljs-built_in">int</span> dwAttribute, <span class="hljs-keyword">ref</span> <span class="hljs-built_in">int</span> pvAttribute, <span class="hljs-built_in">int</span> cbAttribute</span>)</span>;<br></code></pre></td></tr></table></figure>
<p>回到 MyFormBase，重写 OnHandleCreated (表示当窗口句柄 (HWND) 创建时，此时可以拿到 Handle)，并密封防止子类修改 (根据具体需求决定)</p>
<p class="note note-info"><strong>为什么要在 OnHandleCreated 方法里面调用 API，不能在构造函数里面吗？</strong><br>其一，此时获取句柄是最好最安全的，如果在构造函数中获取句柄会导致其提前被创建，可能会有潜在的后果；其二，为了避免有时在运行过程中需要重绘导致句柄也重新创建的极端情况，所有推荐最好在 OnHandleCreated 里调用 API，不然一旦句柄重新创建，主题就没了。</p>

<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyFormBase</span> : <span class="hljs-title">Form</span><br>&#123;<br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnHandleCreated</span>(<span class="hljs-params">EventArgs e</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (ThemeManager.CanUseDarkTheme)<br>        &#123;<br>            ThemeManager.FlushWindow(Handle);<br>        &#125;<br><br>        <span class="hljs-keyword">base</span>.OnHandleCreated(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>最终效果：</p>
<p><img src="/archive-imgs/38/1-dark-form.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="Panel-Label-LinkLabel-PictureBox"><a href="#Panel-Label-LinkLabel-PictureBox" class="headerlink" title="Panel&#x2F;Label&#x2F;LinkLabel&#x2F;PictureBox"></a>Panel&#x2F;Label&#x2F;LinkLabel&#x2F;PictureBox</h3><p>这些控件都能跟随 <code>Form</code> 的前背景颜色，只不过 <code>LinkLabel</code> 要手动设置 <code>LinkColor</code>：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyLinkLabel</span> : <span class="hljs-title">LinkLabel</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyLinkLabel</span>()</span><br>    &#123;<br>        AutoSize = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">if</span> (ThemeManager.CanUseDarkTheme)<br>        &#123;<br>            LinkColor = ThemeManager.DarkForeLink;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>最终效果：</p>
<p><img src="/archive-imgs/38/9-dark-panel-label-link-picbox.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="GroupBox"><a href="#GroupBox" class="headerlink" title="GroupBox"></a>GroupBox</h3><p>GroupBox 的表现有点奇怪，我们先来看看默认效果：</p>
<p><img src="/archive-imgs/38/10-undark-gbox.png" srcset="/img/loading.gif" lazyload></p>
<p>可见标题依旧是黑色的，但里面的 Label 却正常，这说明 ForeColor、BackColor 只对它的子控件生效，不包括标题的颜色。还有一个细节不知道你发现没有，这个边框的颜色太白了，使得整个控件显得有点复古，但边框颜色也不能更改，怎么办呢？</p>
<p>这种情况下就要请出我们万能的 自绘 了，全称 自定义绘制 (Owner Draw)，也就是利用 GDI&#x2F;GDI+ 自己画控件的样式，虽然听着麻烦，但实际也能接受。也不用担心会有性能问题，因为控件本来也是这么画出来的，只不过都是系统预设而已，我们自己画说不定比系统还高效。</p>
<p>首先我们创建一个 MyGroupBox 继承自 GroupBox</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyGroupBox</span> : <span class="hljs-title">GroupBox</span><br>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<p>然后重写 OnPaint 方法，这里参考了 <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=_7NwVqfNU1g">@mikecodz2821</a> 的代码。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span>(<span class="hljs-params">PaintEventArgs e</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (ThemeManager.CanUseDarkTheme)<br>    &#123;<br>        <span class="hljs-keyword">var</span> g = e.Graphics; <span class="hljs-comment">// 获取 Graphics，用来画画</span><br>        <span class="hljs-keyword">var</span> client = ClientSize; <span class="hljs-comment">// 获取 GroupBox 的客户区大小</span><br>        <span class="hljs-keyword">var</span> text = Text; <span class="hljs-comment">// 获取标题</span><br>        <span class="hljs-keyword">var</span> font = Font; <span class="hljs-comment">// 获取字体</span><br>        <span class="hljs-keyword">var</span> textHeight = font.Height / <span class="hljs-number">2</span> + <span class="hljs-number">2</span>; <span class="hljs-comment">// 获取标题的高度，即字体的高度，/2 +2 是让文字在中心线上再向上偏移 2px，</span><br>                                              <span class="hljs-comment">// 因为 GroupBox 的文字和边框上边缘本来就有偏移，没在竖直中心</span><br>        <span class="hljs-keyword">var</span> rect = <span class="hljs-keyword">new</span> Rectangle(<span class="hljs-number">0</span>, textHeight, client.Width, client.Height - textHeight); <span class="hljs-comment">// 表示 GroupBox 的边框位置和大小</span><br>        <span class="hljs-keyword">var</span> textRect = Rectangle.Inflate(ClientRectangle, <span class="hljs-number">-4</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// 让标题向右偏移一点，不然太靠前了</span><br><br>        ControlPaint.DrawBorder(g, rect, ThemeManager.DarkBorder, ButtonBorderStyle.Solid); <span class="hljs-comment">// GDI+ 画边框，颜色用我们定义的，看起来是深灰色</span><br>        TextRenderer.DrawText(g, text, font, textRect, ForeColor, BackColor, TextFormatFlags.Top | TextFormatFlags.Left | TextFormatFlags.LeftAndRightPadding | TextFormatFlags.EndEllipsis); <span class="hljs-comment">// GDI 画文字，并使用设置的 ForeColor, BackColor</span><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">base</span>.OnPaint(e); <span class="hljs-comment">// 不是深色模式就交给系统来画</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>看看效果：</p>
<p><img src="/archive-imgs/38/11-dark-gbox.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="ContextMenu"><a href="#ContextMenu" class="headerlink" title="ContextMenu"></a>ContextMenu</h3><p>不同于 ContextMenuStrip，ContextMenu 是 WinForms 对 Win32 原生快捷菜单的低级封装 (继承自 Component)，外观也比 Strip 好看很多。本文只对 ContextMenu 的深色主题进行讨论，同时如果你对右键菜单没有放置特殊控件的需求的话，也建议迁移到 ContextMenu。</p>
<p>有关如何创建 ContextMenu，可以看看<a href="https://wanghaonie.github.io/posts/95b4fdac793d/">这篇</a>文章。</p>
<p>ContextMenu 的深色主题可以用系统提供的 API，这是一个未公开的 API，不排除微软有可能在未来修改&#x2F;删除它的可能，但现阶段没有问题，那我们就悄悄的用。调用之后整个应用程序范围内的 ContextMenu 全部都有深色主题了。</p>
<p>转到 ThemeManager，添加以下 WinAPI 以及枚举。由于这个函数没有公开，且通过一些手段发现它在 uxtheme.dll 中导出的序号为 135，故需要显式指定 EntryPoint，用 # 表示让 CLR (.NET 运行时) 将 135 当作序号去调用函数而不是名称。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ThemeManager</span><br>&#123;<br>    <span class="hljs-comment">// ...</span><br><br>    [<span class="hljs-meta">DllImport(<span class="hljs-string">&quot;uxtheme.dll&quot;</span>, EntryPoint = <span class="hljs-string">&quot;#135&quot;</span>)</span>]<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">extern</span> <span class="hljs-built_in">int</span> <span class="hljs-title">SetPreferredAppMode</span>(<span class="hljs-params">PreferredAppMode preferredAppMode</span>)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> PreferredAppMode <span class="hljs-comment">// 我们一般把枚举写在类的外面，避免嵌套，不然在访问的时候还要加类名</span><br>&#123;<br>    Default,<br>    AllowDark,<br>    ForceDark, <span class="hljs-comment">// 一般用这个枚举，表示强制将应用程序主题设置为深色，值为 2</span><br>    ForceLight,<br>    Max<br>&#125;<br></code></pre></td></tr></table></figure>

<p>转到程序的入口 (Program.cs)，在 Main 方法中的 Application 系列方法之前调用它。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    [<span class="hljs-meta">STAThread</span>]<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (ThemeManager.CanUseDarkTheme)<br>        &#123;<br>            ThemeManager.SetPreferredAppMode(PreferredAppMode.ForceDark);<br>        &#125;<br><br>        Application.EnableVisualStyles();<br>        Application.SetCompatibleTextRenderingDefault(<span class="hljs-literal">false</span>);<br>        Application.Run(<span class="hljs-keyword">new</span> Form1());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>右键窗体标题栏就能看到了，这是最终效果：</p>
<p><img src="/archive-imgs/38/12-dark-contextmenu.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="Button"><a href="#Button" class="headerlink" title="Button"></a>Button</h3><p>按钮的深色主题的应用就简单很多了，只需在 ThemeManager 里添加以下 WinAPI</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">DllImport(<span class="hljs-string">&quot;uxtheme.dll&quot;</span>, CharSet = CharSet.Unicode)</span>] <span class="hljs-comment">// Unicode 表示传入的字符串都被当作 宽字符 处理</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">extern</span> <span class="hljs-built_in">int</span> <span class="hljs-title">SetWindowTheme</span>(<span class="hljs-params">IntPtr hWnd, <span class="hljs-built_in">string</span> pszSubAppName, <span class="hljs-built_in">string</span> pszSubIdList</span>)</span>;<br></code></pre></td></tr></table></figure>

<p>然后创建 MyButton 继承自 Button，重写 OnHandleCreated</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyButton</span> : <span class="hljs-title">Button</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyButton</span>(<span class="hljs-params">ContextMenu menu</span>)</span><br>    &#123;<br>        FlatStyle = FlatStyle.System; <span class="hljs-comment">// 让按钮使用系统样式</span><br>        UseVisualStyleBackColor = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnHandleCreated</span>(<span class="hljs-params">EventArgs e</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (ThemeManager.CanUseDarkTheme)<br>        &#123;<br>            ThemeManager.SetWindowTheme(Handle, <span class="hljs-string">&quot;DarkMode_Explorer&quot;</span>, <span class="hljs-literal">null</span>); <br>        &#125;<br><br>        <span class="hljs-keyword">base</span>.OnHandleCreated(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>“DarkMode_Explorer” 是系统内置的 (位于 aero.msstyles 文件) 包含深色 Button 的主题的名称；第三个参数按理来说应该传入 “Button”，但传入 null 会让 API 自己去判断用哪个，所以也可以直接传 null。</p>
<p class="note note-info"><strong>你知道吗？</strong><br><a href="https://github.com/nptr/msstyleEditor" target="_blank">msstyleEditor</a> 是专门用于解析和修改 *.msstyles 文件的工具，我们可以通过该软件来查看带有 DarkMode_ 前缀的类名，以及它支持的控件</p>

<p>看看效果：</p>
<p><img src="/archive-imgs/38/13-dark-button.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="RadioButton-CheckBox"><a href="#RadioButton-CheckBox" class="headerlink" title="RadioButton&#x2F;CheckBox"></a>RadioButton&#x2F;CheckBox</h3><p>这两个控件其实也和 Button 差不多，但在禁用状态时，文字会看不清，可能是 WinForms 封装时某些代码干扰了主题运作，所以就单独提出来了。</p>
<p>由于这两个控件在 WinForms&#x2F;Win32 中都继承自 ButtonBase&#x2F;Button，所以我们可以创建一个辅助类来侧载。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyButtonBase</span> <span class="hljs-comment">// 注意，不用显式继承自任何基类</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> ButtonBase Target;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyButtonBase</span>(<span class="hljs-params">ButtonBase target</span>)</span><br>    &#123;<br>        target.UseVisualStyleBackColor = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">if</span> (ThemeManager.CanUseDarkTheme)<br>        &#123;<br>            Target = target;<br>            Target.EnabledChanged += Button_EnabledChanged; <span class="hljs-comment">// 绑定启用状态更改事件</span><br>            UpdateStyle();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Button_EnabledChanged</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br>    &#123;<br>        UpdateStyle();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">UpdateStyle</span>()</span><br>    &#123;<br>        Target.FlatStyle = Target.Enabled ? FlatStyle.Standard : FlatStyle.System;<br>        ThemeManager.SetWindowTheme(Target.Handle, <span class="hljs-string">&quot;DarkMode_Explorer&quot;</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">// 根据多次试验，我发现当启用时使用 Standard 主题，禁用时用 System 主题可以有效解决文字看不清的问题</span><br>        <span class="hljs-comment">// 记得要再次调用 API 刷新主题。</span><br>    &#125;<br><br>    ~MyButtonBase()<br>    &#123;<br>        <span class="hljs-keyword">if</span> (Target != <span class="hljs-literal">null</span>)<br>        &#123;<br>            Target.EnabledChanged -= Button_EnabledChanged; <span class="hljs-comment">// 析构函数解绑事件，也可以不用</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>同样我们也需要创建 MyRadioButton 和 MyCheckBox，然后在构造函数中直接创建辅助类实例就完成了</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyRadioButton</span> : <span class="hljs-title">RadioButton</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyRadioButton</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">new</span> MyButtonBase(<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyCheckBox</span> : <span class="hljs-title">CheckBox</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyCheckBox</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">new</span> MyButtonBase(<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>看看效果：</p>
<p><img src="/archive-imgs/38/14-dark-rb-cb.png" srcset="/img/loading.gif" lazyload></p>
<p>你会发现在禁用状态下，文字会更偏向左侧，但这在 Win32 中是没有的，WinForms 的话也只能暂时这样了。</p>
<h3 id="TextBox-ComboBox"><a href="#TextBox-ComboBox" class="headerlink" title="TextBox&#x2F;ComboBox"></a>TextBox&#x2F;ComboBox</h3><p>这两玩意儿也比较好搞，不过除了需要调用 API，还需要设置 ForeColor、BackColor。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyComboBox</span> : <span class="hljs-title">ComboBox</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyComboBox</span>()</span><br>    &#123;<br>        DropDownStyle = ComboBoxStyle.DropDownList; <span class="hljs-comment">// 表示 ComboBox 应具有下拉菜单</span><br>        FlatStyle = FlatStyle.System;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnHandleCreated</span>(<span class="hljs-params">EventArgs e</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (ThemeManager.CanUseDarkTheme)<br>        &#123;<br>            ForeColor = ThemeManager.DarkFore;<br>            BackColor = ThemeManager.DarkBack;<br>            ThemeManager.SetWindowTheme(Handle, <span class="hljs-string">&quot;DarkMode_CFD&quot;</span>, <span class="hljs-literal">null</span>); <br>        &#125;<br><br>        <span class="hljs-keyword">base</span>.OnHandleCreated(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyTextBox</span> : <span class="hljs-title">TextBox</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnHandleCreated</span>(<span class="hljs-params">EventArgs e</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (ThemeManager.CanUseDarkTheme)<br>        &#123;<br>            ForeColor = ThemeManager.DarkFore;<br>            BackColor = ThemeManager.DarkBack;<br>            ThemeManager.SetWindowTheme(Handle, <span class="hljs-string">&quot;DarkMode_CFD&quot;</span>, <span class="hljs-literal">null</span>); <br>        &#125;<br><br>        <span class="hljs-keyword">base</span>.OnHandleCreated(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意包含它们两个的深色主题的名称是 “DarkMode_CFD”。</p>
<p>看看效果：</p>
<p><img src="/archive-imgs/38/15-dark-textbox-combobox.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="TreeView-TabControl"><a href="#TreeView-TabControl" class="headerlink" title="TreeView&#x2F;TabControl"></a>TreeView&#x2F;TabControl</h3><p>可能大家很少用这个控件，这里提出来也是利用它作为垂直导航栏来代替 TabControl，因为 TabControl 的深色主题不好搞，详见 <a href="https://wanghaonie.github.io/posts/818a54b277f2/">摆脱 TabControl，教你打造高颜值原生样式的垂直导航栏</a>。</p>
<p>当然我们也可以直接用，首先来创建 MyTreeView</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyTreeView</span> : <span class="hljs-title">TreeView</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnHandleCreated</span>(<span class="hljs-params">EventArgs e</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (ThemeManager.CanUseDarkTheme)<br>        &#123;<br>            ForeColor = ThemeManager.DarkFore;<br>            BackColor = ThemeManager.DarkBack;<br>            ThemeManager.SetWindowTheme(Handle, <span class="hljs-string">&quot;DarkMode_Explorer&quot;</span>, <span class="hljs-literal">null</span>); <br>        &#125;<br><br>        <span class="hljs-keyword">base</span>.OnHandleCreated(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>看看效果：</p>
<p><img src="/archive-imgs/38/16-dark-treeview.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="NumericUpDown"><a href="#NumericUpDown" class="headerlink" title="NumericUpDown"></a>NumericUpDown</h3><p>NumericUpDown 是本文中遇到的第一个复合控件，也就是说它由两个控件组成：UpDownEdit 和 UpDownButtons，当然这两个类型是专有的，所以我们不能在公开类型里找到。</p>
<p><img src="/archive-imgs/38/19-nud-components.png" srcset="/img/loading.gif" lazyload></p>
<p>但这并不代表我们不能通过代码获得它们的实例，当然也不需要反射。想想，如果是你，要将多个控件放在一个容器里面，你会怎么做？</p>
<p>是不是往 Controls 集合里塞就对了？所以我们直接遍历 NumericUpDown 的 Controls 集合就能看到它俩了。</p>
<p>首先老规矩，创建 MyNumericUpDown，设置必要属性，重写 OnHandleCreated：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyNumericUpDown</span> : <span class="hljs-title">NumericUpDown</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyNumericUpDown</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (ThemeManager.CanUseDarkTheme)<br>        &#123;<br>            ForeColor = ThemeManager.DarkFore;<br>            BackColor = ThemeManager.DarkBack;<br>        &#125;<br><br>        TextAlign = HorizontalAlignment.Right;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnHandleCreated</span>(<span class="hljs-params">EventArgs e</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">base</span>.OnHandleCreated(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们先试着在 OnHandleCreated 里遍历一下，看看有没有收获。顺便在 foreach 这里打个断点</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnHandleCreated</span>(<span class="hljs-params">EventArgs e</span>)</span><br>&#123;<br>    <span class="hljs-keyword">foreach</span> (Control control <span class="hljs-keyword">in</span> Controls) <span class="hljs-comment">// &lt;- 断点</span><br>    &#123;<br>        <br>    &#125;<br><br>    <span class="hljs-keyword">base</span>.OnHandleCreated(e);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>看看效果</p>
<p><img src="/archive-imgs/38/20-nud-components-vsbpoint.png" srcset="/img/loading.gif" lazyload></p>
<p>可见确实由两个控件组成，分别是 UpDownButtons 和 UpDownEdit。</p>
<p>那我们就直接应用主题。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">foreach</span> (Control control <span class="hljs-keyword">in</span> Controls) <span class="hljs-comment">// &lt;- 断点</span><br>&#123;<br>    ThemeManager.SetWindowTheme(control.Handle, <span class="hljs-string">&quot;DarkMode_Explorer&quot;</span>, <span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其实 DarkMode_CFD 也可以，但只对 UpDownEdit 生效，使用 DarkMode_Explorer 的话两者都可以被应用深色主题。</p>
<p>看看效果：</p>
<p><img src="/archive-imgs/38/21-dark-nud.png" srcset="/img/loading.gif" lazyload></p>
<p>注意，Windows 11 之前的系统，UpDownButtons 没有深色主题是正常现象。</p>
<h3 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h3><p>ListView 就比较复杂了，因为它也是复合控件，标题栏就是一个控件 (SysHeader32)，列表就是 ListView 本身，我们还是按照老办法来看看 Controls 集合。</p>
<p>先创建 MyListView，设置必要属性</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyListView</span> : <span class="hljs-title">ListView</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyListView</span>()</span><br>    &#123;<br>        View = View.Details; <span class="hljs-comment">// 列表详细视图</span><br>        FullRowSelect = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 整行选择</span><br>        HideSelection = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 失去焦点不隐藏选中项</span><br>        ShowItemToolTips = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 内容超出范围显示 ToolTip</span><br>        BorderStyle = BorderStyle.None; <span class="hljs-comment">// 不显示白色边框，这个看具体需求</span><br><br>        <span class="hljs-keyword">if</span> (ThemeManager.CanUseDarkTheme)<br>        &#123;<br>            ForeColor = ThemeManager.DarkFore;<br>            BackColor = ThemeManager.DarkBack;<br>        &#125;<br><br>        SetStyle(ControlStyles.AllPaintingInWmPaint | ControlStyles.OptimizedDoubleBuffer, <span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">// 开启双缓冲，防止闪烁与卡顿</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnHandleCreated</span>(<span class="hljs-params">EventArgs e</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> b = Controls; <span class="hljs-comment">// &lt;- 打断点</span><br><br>        <span class="hljs-keyword">if</span> (ThemeManager.CanUseDarkTheme)<br>        &#123;<br>            ThemeManager.SetWindowTheme(Handle, <span class="hljs-string">&quot;DarkMode_ItemsView&quot;</span>, <span class="hljs-literal">null</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">base</span>.OnHandleCreated(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意 ListView 的主题名称应该是 DarkMode_ItemsView。</p>
<p>看看 Controls 集合：</p>
<p><img src="/archive-imgs/38/22-listview-controls.png" srcset="/img/loading.gif" lazyload></p>
<p>这不天塌了？Controls 里啥也没有，标题栏根本就没在 Controls 里，为什么？</p>
<p>这是因为标题栏是 ListView 底层动态创建的控件，WinForms 根本没有封装，自然就看不到了。那我们怎么看到？</p>
<p>还记得我们安装的 C++ 吗，它会自带 Spy++，我们可以用这个工具探测一下，在 Visual Studio 工具栏：工具 &gt;Spy++</p>
<p><img src="/archive-imgs/38/23-listviewheader-spyxx.png" srcset="/img/loading.gif" lazyload></p>
<p>这不，它在这呢。同时你也可以看到，标题栏根本没有被应用主题。</p>
<p>显然，如果能获取到标题栏的句柄的话，一切都好办了。你可能会想到用 EnumChildWindows 函数枚举子窗口，只能说有思路了，但不够。</p>
<p>如果你在搜索引擎里搜索 listview get header，你会发现：</p>
<p><img src="/archive-imgs/38/24-google-lvh.png" srcset="/img/loading.gif" lazyload></p>
<p>好家伙，居然有一个跟关键词一模一样的函数 (其实是宏)，这也太棒了。<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/commctrl/nf-commctrl-listview_getheader">点</a>进去看看。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">返回值<br>类型：HWND<br><br>返回标头控件的句柄。<br></code></pre></td></tr></table></figure>
<p>看到这行描述没有？—— 返回标头控件的句柄。</p>
<p>那么这个宏是怎么实现的呢？其实就是用 SendMessage 给 ListView 发了一个 LVM_GETHEADER 消息，然后该函数的返回值就是标题栏的句柄。</p>
<p>可能这对刚接触消息循环的朋友比较难懂，那我们来仿生一下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">(你调用了 SendMessage ...)<br><br>SendMessage: @ListView，交出你标题栏的句柄。<br>(SendMessage 向 ListView 的 HWND 发送了 LVM_GETHEADER 消息 ...)<br><br>ListView: 收到，哥们儿！<br>(ListView 内部获取标题栏的 HWND 并传给了 SendMessage ...)<br><br>(你拿到了 SendMessage 的返回值，它就是标题栏的 HWND)<br></code></pre></td></tr></table></figure>

<p>上述操作在 WinAPI 里很常见，需要新手朋友们加深理解，以及适应这种机制。</p>
<p>现在我们就可以转到 C++ 了，因为 ListView 深色主题本来就很复杂。</p>
<p>右键我们的 Natives 项目，选择添加 &gt;新项<br><img src="/archive-imgs/38/25-cpp-new-item.png" srcset="/img/loading.gif" lazyload></p>
<p>选择头文件 (*.h)，命名为 ListViewHelper<br><img src="/archive-imgs/38/26-cpp-new-h.png" srcset="/img/loading.gif" lazyload></p>
<p>头文件第一行默认就是 <code>#pragma once</code>，它是用于防止多次引用的，不要删除</p>
<p>同样方式我们添加一个源文件 (*.cpp)，也命名为 ListViewHelper，并加上预编译头 (Visual Studio 规定的) 和我们的 ListViewHelper.h</p>
<p><img src="/archive-imgs/38/27-created-h-cpp.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;pch.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ListViewHelper.h&quot;</span></span><br></code></pre></td></tr></table></figure>
<p><img src="/archive-imgs/38/28-cpp-add-include.png" srcset="/img/loading.gif" lazyload></p>
<p>转到头文件，添加引用，以及声明导出函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Uxtheme.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;CommCtrl.h&gt;</span></span><br><br><span class="hljs-built_in">cexport</span>(<span class="hljs-type">void</span>) <span class="hljs-built_in">SetListViewTheme</span>(HWND hListView);<br></code></pre></td></tr></table></figure>
<p>参数 hListView 的命名方式表示 Handle of ListView，跟 hWnd (Handle of Window) 保持一致的格式即可，有助于提高可读性</p>
<p>转到源文件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetListViewTheme</span><span class="hljs-params">(HWND hListView)</span> <span class="hljs-comment">// 保持签名与头文件声明的一致</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">SetWindowTheme</span>(hListView, <span class="hljs-string">L&quot;DarkMode_ItemsView&quot;</span>, <span class="hljs-literal">nullptr</span>); <span class="hljs-comment">// 应用到 ListView 自己</span><br>	<span class="hljs-built_in">SetWindowTheme</span>(<span class="hljs-built_in">ListView_GetHeader</span>(hListView), <span class="hljs-string">L&quot;DarkMode_ItemsView&quot;</span>, <span class="hljs-literal">nullptr</span>); <span class="hljs-comment">// 应用到标题栏</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>对于 Win32 新手朋友们，请注意：</p>
<ul>
<li>C# 的 null 在 C++ 里对应 nullptr</li>
<li>C# 的 string <strong>在这里</strong>对应 C++ 的 LPCWSTR (底层类型 <code>const w_char*</code>，宽字符，Unicode)，书写时需要在 <code>&quot;&quot;</code> 左侧加上 <code>L</code>：<code>L&quot;&quot;</code></li>
</ul>
<p>转到 C# 项目，在 ThemeManager 里，声明导入函数：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">DllImport(<span class="hljs-string">&quot;Natives.dll&quot;</span>)</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetListViewTheme</span>(<span class="hljs-params">IntPtr hListView</span>)</span>;<br></code></pre></td></tr></table></figure>

<p>转到 MyListView，删除之前的，直接更改为：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnHandleCreated</span>(<span class="hljs-params">EventArgs e</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (ThemeManager.CanUseDarkTheme)<br>    &#123;<br>        ThemeManager.SetListViewTheme(Handle);<br>    &#125;<br><br>    <span class="hljs-keyword">base</span>.OnHandleCreated(e);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>看看效果</p>
<p><img src="/archive-imgs/38/29-half-dark-listview.png" srcset="/img/loading.gif" lazyload></p>
<p>有点尴尬，你就说有没有主题吧，只是文字没有适应罢了。</p>
<p>那我们还得继续，怎么办呢？直接反手就是个子类化，这里参考了 <a target="_blank" rel="noopener" href="https://github.com/ysc3839/win32-darkmode/blob/master/win32-darkmode/ListViewUtil.h">ysc3839&#x2F;win32-darkmode</a> 的代码。</p>
<p>转到 ListViewHelper.cpp，我们写一个函数表示子类化过程，要写在 SetListViewTheme 前面</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">static</span> LRESULT CALLBACK <span class="hljs-title">ListViewSubclass</span><span class="hljs-params">(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">switch</span> (uMsg)<br>    &#123;<br>        <span class="hljs-keyword">case</span> WM_NOTIFY:<br>        &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">reinterpret_cast</span>&lt;LPNMHDR&gt;(lParam)-&gt;code == NM_CUSTOMDRAW)<br>            &#123;<br>                LPNMCUSTOMDRAW nmcd = <span class="hljs-built_in">reinterpret_cast</span>&lt;LPNMCUSTOMDRAW&gt;(lParam);<br><br>                <span class="hljs-keyword">switch</span> (nmcd-&gt;dwDrawStage)<br>                &#123;<br>                    <span class="hljs-keyword">case</span> CDDS_PREPAINT:<br>                        <span class="hljs-keyword">return</span> CDRF_NOTIFYITEMDRAW;<br>                    <span class="hljs-keyword">case</span> CDDS_ITEMPREPAINT:<br>                        <span class="hljs-built_in">SetTextColor</span>(nmcd-&gt;hdc, <span class="hljs-built_in">RGB</span>(<span class="hljs-number">222</span>, <span class="hljs-number">222</span>, <span class="hljs-number">222</span>));<br>                        <span class="hljs-comment">// (222, 222, 222) 这个颜色跟 Windows 资源管理器的 ListView 的标题栏的文字颜色一样的，表现为浅灰色</span><br>                        <span class="hljs-keyword">return</span> CDRF_DODEFAULT;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> WM_NCDESTROY:<br>        &#123;<br>            <span class="hljs-built_in">RemoveWindowSubclass</span>(hWnd, ListViewSubclass, uIdSubclass);<br>            <span class="hljs-comment">// 记得在 ListView 关闭时移除子类化函数</span><br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">DefSubclassProc</span>(hWnd, uMsg, wParam, lParam); <span class="hljs-comment">// 让 DefSubclassProc 处理我们没有处理的消息</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>原理其实也相当于自绘，只不过比较高明，这也是微软推荐的方式，而不是重写 OnPaint (WM_PAINT)。</p>
<p>转到 SetListViewTheme 函数，启用子类化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetListViewTheme</span><span class="hljs-params">(HWND hListView)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">SetWindowSubclass</span>(hListView, ListViewSubclass, <span class="hljs-built_in">reinterpret_cast</span>&lt;UINT_PTR&gt;(hListView), <span class="hljs-number">0</span>);<br><br>	<span class="hljs-built_in">SetWindowTheme</span>(hListView, <span class="hljs-string">L&quot;DarkMode_ItemsView&quot;</span>, <span class="hljs-literal">nullptr</span>);<br>	<span class="hljs-built_in">SetWindowTheme</span>(<span class="hljs-built_in">ListView_GetHeader</span>(hListView), <span class="hljs-string">L&quot;DarkMode_ItemsView&quot;</span>, <span class="hljs-literal">nullptr</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>看看效果</p>
<p><img src="/archive-imgs/38/30-dark-listview-no-tt.png" srcset="/img/loading.gif" lazyload></p>
<p>你以为就完了吗，如果我们把内容弄长一点，然后鼠标放上去，你就会发现…</p>
<p><img src="/archive-imgs/38/31-undark-listview-tt.png" srcset="/img/loading.gif" lazyload></p>
<p>惊不惊喜，意不意外！还有一个控件呢！</p>
<p>这是什么？它的学名叫 ToolTip，用于… emmm … 反正就长这样，但它实际上是一个窗口。那么这个玩意儿的句柄怎么获取，然后应用深色主题呢？老样子，先看文档，文档没有再想其他办法。</p>
<p>转到我们之前找到的 ListView_GetHeader 的<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/commctrl/nf-commctrl-listview_getheader">页面</a>，看看左侧，这是什么？你不觉得对它有个很微妙的感觉吗，感觉有什么好东西就要来了？</p>
<p><img src="/archive-imgs/38/32-msdoc-lv-get-tt-mac.png" srcset="/img/loading.gif" lazyload></p>
<p>直接点进去，看看它是干什么的</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">返回值<br>类型：HWND<br><br>返回工具提示 (ToolTip) 控件的句柄。<br></code></pre></td></tr></table></figure>
<p>看吧，果然，这不就是我们想要的？开搞！</p>
<p>转到 ListViewHelper.cpp 的 SetListViewTheme 那里：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetListViewTheme</span><span class="hljs-params">(HWND hListView)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">SetWindowSubclass</span>(hListView, ListViewSubclass, <span class="hljs-built_in">reinterpret_cast</span>&lt;UINT_PTR&gt;(hListView), <span class="hljs-number">0</span>);<br>	<span class="hljs-built_in">SetWindowTheme</span>(hListView, <span class="hljs-string">L&quot;DarkMode_ItemsView&quot;</span>, <span class="hljs-literal">nullptr</span>);<br>	<span class="hljs-built_in">SetWindowTheme</span>(<span class="hljs-built_in">ListView_GetHeader</span>(hListView), <span class="hljs-string">L&quot;DarkMode_ItemsView&quot;</span>, <span class="hljs-literal">nullptr</span>);<br>	<span class="hljs-built_in">SetWindowTheme</span>(<span class="hljs-built_in">ListView_GetToolTips</span>(hListView), <span class="hljs-string">L&quot;DarkMode_Explorer&quot;</span>, <span class="hljs-literal">nullptr</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>看看效果：</p>
<p><img src="/archive-imgs/38/33-dark-listview-tt.png" srcset="/img/loading.gif" lazyload></p>
<p>你以为又完了吗？如果我们把 ListView 的列和行多弄几个，这里就缩小窗体及 ListView 来模拟同样的效果。你会发现…</p>
<p><img src="/archive-imgs/38/36-undark-lv-sb.png" srcset="/img/loading.gif" lazyload></p>
<p>是不是有点心肺骤停，这俩滚动条 (H&#x2F;VScrollBar) 太刺眼了，这可怎么办呢？先来看看 Spy++ 有没有探测到</p>
<p><img src="/archive-imgs/38/37-undark-lvsb-spyxx.png" srcset="/img/loading.gif" lazyload></p>
<p>完辣！简直就是道高一尺魔高一丈，我们每想个新方法总能遇到把我们打回原形的情况。这俩小白条压根就没句柄，那我们也没必要指望什么 ListView_GetH&#x2F;VScrollBar 了，因为微软也没有提供相关的宏。</p>
<p>但要知道，在标准 Win32 控件里，ScrollBar 是个独立的控件，拥有 HWND。那这是怎么回事呢？</p>
<p>因为这两小白条是 ListView 的 “私生子”，是被 ListView 画出来的，压根就没有走创建控件的方式，自然就没有 HWND 了。</p>
<p>那这要怎么办呢？这就涉及到更底层的原理了，如果我们将控件的绘制想象为贴图的渲染，那这些贴图总得有个来源吧。所以我们要修改内部贴图？不，这工作量太大了。我们可以劫持！用 IAT Hook。这个 Hook 的工作原理通俗来说就是在对方毫不知情的情况下进行偷梁换柱。当 ListView 访问滚动条的贴图时，我们给它来个重定向，让它去画有深色主题的滚动条。</p>
<p>可能对于新手朋友来说理解起来又有些吃力了，那我们再来仿生一下。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs text">(ListView 来到贴图商店 ...)<br><br>ListView: 老板，给我来一份 ScrollBar 的贴图<br>(ListView 调用了一个未公开的 API)<br><br>UxTheme: 好的，给你 Explorer::ScrollBar<br>(这是正常情况，但现在我们通过 IAT Hook 黑了老板的号，于是就变成了...)<br><br>IAT_Hook: (小声) @Natives (我们的 DLL)，ListView 来买 ScrollBar 了，快把新老板给我，我帮你替换<br><br>Natives: 收到！@IAT_Hook<br>(我们让 IAT Hook 更换了商店的老板，这个老板只听我们的话，且让新老板站在旧老板的位置)<br><br>UxTheme (Hacked): 好的，给你 DarkMode_Explorer::ScrollBar<br></code></pre></td></tr></table></figure>

<p>大概就是这样，具体实现，我们放到下一个专题。</p>
<h3 id="ScrollBar"><a href="#ScrollBar" class="headerlink" title="ScrollBar"></a>ScrollBar</h3><p>ScrollBar，即滚动条，是标准的 Win32 控件 (也就是有 HWND)，WinForms 里也有封装 (HScrollBar 和 VScrollBar)。在创建 ScrollBar 时，我们可以通过指定 SBS_HORZ 或 SBS_VERT 来决定滚动条的朝向。</p>
<p>如果能获取到句柄的话，那我们直接调用 SetWindowTheme 函数设置为 DarkMode_Explorer 主题就完事了，那没有句柄呢？</p>
<p>没有句柄的情况常见于多数可滚动的控件 (比如上方提到的 ListView、TreeView)，它们的滚动条都是自己画的，而不是创建的标准控件，是不具有 HWND 的。</p>
<p>插播一条，你有没有发现 TreeView 的滚动条在我们处理后就直接变深色了，而 ListView 却不行？因为 TreeView 也是用的是 DarkMode_Explorer 主题，这个主题是包括滚动条的，而 ListView 使用的 DarkMode_ItemsView 是不包括滚动条的，自然就没有深色主题了。</p>
<p>这种情况下，要想应用深色主题，就要先明白它们是通过怎么样的方式获取到贴图。</p>
<p>通过一些手段，我们发现在 uxtheme.dll 的第 49 个入口，导出了一个叫 OpenNcThemeData 的函数，这个函数就是用来获取控件的非客户区的主题的数据的，其中就包括了滚动条。</p>
<p>如果能监测应用程序访问 OpenNcThemeData 的话，我们就能进行偷梁换柱，让应用程序获取到 DarkMode_Explorer 里的 ScrollBar。</p>
<p>这个监测手段就叫 IAT Hook，它的作用是修改目标模块的导入表，把原本指向某个 API 的函数指针替换成我们定义的钩子函数。</p>
<p>具体怎么实现呢？这里我们又参考了 <a target="_blank" rel="noopener" href="https://github.com/ysc3839/win32-darkmode/blob/master/win32-darkmode/IatHook.h">ysc3839&#x2F;win32-darkmode</a> 的代码。</p>
<p>我们下载并导入 (右键 C++ 项目，选择 添加 &gt;现有项) ysc3839 大佬提供的头文件</p>
<p><img src="/archive-imgs/38/38-cpp-import-iathook.png" srcset="/img/loading.gif" lazyload></p>
<p>并在 ListViewHelper.cpp 里添加引用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;IatHook.h&quot;</span></span><br></code></pre></td></tr></table></figure>

<p>转到 ListViewHelper.h，添加一个导出函数，表示 修复滚动条(的深色主题)：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">cexport</span>(<span class="hljs-type">void</span>) <span class="hljs-built_in">FixScrollBar</span>();<br></code></pre></td></tr></table></figure>

<p>转到 ListViewHelper.cpp，添加 OpenNcThemeData 函数指针和 FixScrollBar 主体</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> fnOpenNcThemeData = <span class="hljs-built_in">HTHEME</span> (WINAPI*)(HWND hWnd, LPCWSTR pszClassList);<br>fnOpenNcThemeData OpenNcThemeData = <span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FixScrollBar</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    HMODULE hUxtheme = <span class="hljs-built_in">LoadLibraryEx</span>(<span class="hljs-string">L&quot;uxtheme.dll&quot;</span>, <span class="hljs-literal">nullptr</span>, LOAD_LIBRARY_SEARCH_SYSTEM32);<br>    HMODULE hComctl = <span class="hljs-built_in">LoadLibraryEx</span>(<span class="hljs-string">L&quot;comctl32.dll&quot;</span>, <span class="hljs-literal">nullptr</span>, LOAD_LIBRARY_SEARCH_SYSTEM32);<br>    <span class="hljs-comment">// 动态加载 uxtheme.dll 和 comctl32.dll (这个是 Win32 控件库)</span><br><br>    <span class="hljs-keyword">if</span> (hUxtheme)<br>    &#123;<br>        <span class="hljs-keyword">auto</span> addr = <span class="hljs-built_in">GetProcAddress</span>(hUxtheme, <span class="hljs-built_in">MAKEINTRESOURCEA</span>(<span class="hljs-number">49</span>));<br><br>        <span class="hljs-keyword">if</span> (addr)<br>        &#123;<br>            OpenNcThemeData = <span class="hljs-built_in">reinterpret_cast</span>&lt;fnOpenNcThemeData&gt;(addr);<br>            <span class="hljs-comment">// 将指针指向 49 号入口，我们就能直接调用 OpenNcThemeData 了，这就类似于我们在 C# Interop 指定 DllImport #49</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (hComctl)<br>    &#123;<br>        <span class="hljs-keyword">auto</span>* addr = <span class="hljs-built_in">FindDelayLoadThunkInModule</span>(hComctl, <span class="hljs-string">&quot;uxtheme.dll&quot;</span>, <span class="hljs-number">49</span>);<br><br>        <span class="hljs-keyword">if</span> (addr)<br>        &#123;<br>            DWORD oldProtect;<br><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">VirtualProtect</span>(addr, <span class="hljs-built_in">sizeof</span>(IMAGE_THUNK_DATA), PAGE_READWRITE, &amp;oldProtect))<br>            &#123;<br>                <span class="hljs-keyword">auto</span> MyOpenThemeData = [](HWND hWnd, LPCWSTR classList) -&gt; HTHEME<br>                &#123;<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">wcscmp</span>(classList, <span class="hljs-string">L&quot;ScrollBar&quot;</span>) == <span class="hljs-number">0</span>)<br>                    &#123;<br>                        hWnd = <span class="hljs-literal">nullptr</span>;<br>                        classList = <span class="hljs-string">L&quot;DarkMode_Explorer::ScrollBar&quot;</span>;<br>                    &#125;<br><br>                    <span class="hljs-comment">// 偷梁换柱，检测是否访问了名为 ScrollBar 的主题，若是则替换为 DarkMode_Explorer::ScrollBar</span><br><br>                    <span class="hljs-keyword">return</span> <span class="hljs-built_in">OpenNcThemeData</span>(hWnd, classList);<br>                &#125;;<br><br>                addr-&gt;u1.Function = <span class="hljs-built_in">reinterpret_cast</span>&lt;ULONG_PTR&gt;(<span class="hljs-built_in">static_cast</span>&lt;fnOpenNcThemeData&gt;(MyOpenThemeData));<br>                <span class="hljs-built_in">VirtualProtect</span>(addr, <span class="hljs-built_in">sizeof</span>(IMAGE_THUNK_DATA), oldProtect, &amp;oldProtect);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>转到 ThemeManager.cs，声明导入函数</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">DllImport(<span class="hljs-string">&quot;Natives.dll&quot;</span>)</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span> <span class="hljs-title">FixScrollBar</span>()</span>;<br></code></pre></td></tr></table></figure>
<p>转到程序的入口 (Program.cs)，在我们之前设置 ContextMenu 深色主题的那个地方之前调用它。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    [<span class="hljs-meta">STAThread</span>]<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (ThemeManager.CanUseDarkTheme)<br>        &#123;<br>            ThemeManager.FixScrollBar();<br>            ThemeManager.SetPreferredAppMode(PreferredAppMode.ForceDark);<br>        &#125;<br><br>        Application.EnableVisualStyles();<br>        Application.SetCompatibleTextRenderingDefault(<span class="hljs-literal">false</span>);<br>        Application.Run(<span class="hljs-keyword">new</span> Form1());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>看看效果：</p>
<p><img src="/archive-imgs/38/36-undark-lv-sb.png" srcset="/img/loading.gif" lazyload></p>
<p>有点匪夷所思了呢，回头看看我们的代码有没有漏写什么？</p>
<p>… 加载了 uxtheme.dll 和 comctl32.dll，然后找入口，OpenNcThemeData 函数指针也理论上来说不是 nullptr … 没有问题啊，怎么回事呢？</p>
<p>于是你打开了某工具 (我常用 System Informer)，看看我们的应用程序是否加载了相应的 dll。</p>
<p><img src="/archive-imgs/38/40-loaded-uxtheme.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/archive-imgs/38/39-loaded-comctl32.png" srcset="/img/loading.gif" lazyload></p>
<p>你发现 uxtheme 已加载了，但 … 怎么有两个 comctl32？</p>
<p>展开文件路径，你会发现两个 comctl32 的版本都不一样，一个 v6 一个 v5！</p>
<p>这又是什么情况呢？经查询，我们得知：</p>
<ul>
<li>WinForms 的 Application.EnableVisualStyles() 会使 Win32 控件具有现代样式，也就是要加载 CommCtrl v6，否则就是复古样式 (v5)</li>
<li>传统 Win32 应用程序中，要想达到和 WinForms 一样的效果，必须要在清单里声明 CommCtrl v6</li>
</ul>
<p>也就是说那个 v5 是我们的 FixScrollBar 函数加载的，钩子都钩错地方了，我们预期要钩住 v6 的。</p>
<p>打开我们之前为我们 C# 程序添加的 app.manifest 文件，添加以下内容：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">assembly</span> <span class="hljs-attr">manifestVersion</span>=<span class="hljs-string">&quot;1.0&quot;</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;urn:schemas-microsoft-com:asm.v1&quot;</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 添加以下的，其他不变 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependentAssembly</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">assemblyIdentity</span></span><br><span class="hljs-tag">          <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;win32&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Microsoft.Windows.Common-Controls&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;6.0.0.0&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">processorArchitecture</span>=<span class="hljs-string">&quot;*&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">publicKeyToken</span>=<span class="hljs-string">&quot;6595b64144ccf1df&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">language</span>=<span class="hljs-string">&quot;*&quot;</span></span><br><span class="hljs-tag">        /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependentAssembly</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">assembly</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>下面就是见证奇迹的时刻：</p>
<p><img src="/archive-imgs/38/41-dark-lvsb.png" srcset="/img/loading.gif" lazyload></p>
<p>简直可以说是完美！ListView 的深色主题就到此为止了</p>
<p>另外，要注意的是 FixScrollBar 的作用范围是整个应用程序内的滚动条，而不是只有这个 ListView。</p>
<h3 id="ColorDialog-FontDialog"><a href="#ColorDialog-FontDialog" class="headerlink" title="ColorDialog&#x2F;FontDialog"></a>ColorDialog&#x2F;FontDialog</h3><p>这两个对话框大家都不陌生吧，就是系统内置的挑选颜色、字体的对话框。你有没有想过更改它们的样式或者行为呢？</p>
<p>可能你想过，但你发现它们并没有 Handle 属性，也就是获取不到 HWND，就什么也干不了，于是你放弃了这一想法。</p>
<p>今天，在这里，我们可以把这个想法变成现实。</p>
<p>打开微软文档，查询 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.forms.commondialog">CommonDialog</a>，我们发现该类提供了一个虚方法：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">HookProc(IntPtr hWnd, <span class="hljs-built_in">int</span> msg, IntPtr wparam, IntPtr lparam);    <span class="hljs-comment">// 定义要重写的通用对话框挂钩过程，以便向通用对话框添加特定功能。</span><br></code></pre></td></tr></table></figure>

<p>并且这个方法在 ColorDialog 和 FontDialog 里面也并没有声明为 sealed，也就是说我们可以进一步重写。更关键的是，看到 hWnd 参数了吗，它就是对话框的句柄。</p>
<p>所以我们可以重写 HookProc 来拿到句柄，而不是用什么 Handle 属性。</p>
<p>在重写之前，我们先新建一个辅助类，因为这两个对话框处理方式是一样的，命名为 CommonDialogHelper。该类具有一个构造函数，允许我们传入当前对话框实例，以及 HookProc</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CommonDialogHelper</span>(<span class="hljs-params">CommonDialog dialog, MyFormBase parent, HOOKPROC DefHookProc</span>) <span class="hljs-comment">// C# 12 的新特性 主构造函数，允许我们声明类的同时声明构造函数</span></span><br>&#123;<br>    <span class="hljs-comment">// DefHookProc 表示默认的 (Default) HookProc，我们依然要保留它，后面会用到</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> IntPtr <span class="hljs-title">HOOKPROC</span>(<span class="hljs-params">IntPtr hWnd, <span class="hljs-built_in">int</span> msg, IntPtr wParam, IntPtr lParam</span>)</span>; <span class="hljs-comment">// HOOKPROC 委托，写在类的外面</span><br></code></pre></td></tr></table></figure>

<p>这里用到了委托，为什么呢？因为我们这里要传入对话框的 HookProc，直接写的话相当于执行这个方法并拿到返回值，但实际上，我们只是想封装这个方法，还不急着执行。所以就要用到委托了，委托就可以帮我们封装方法，等我们需要执行的时候再拿出来执行。那为什么 HOOKPROC 要全大写呢？一是因为使用 HookProc 会产生歧义 (重名了)，二是钩子过程在 Win32 里定义也是 HOOKPROC。</p>
<p>因此我们的辅助类还要提供一个开放的 HookProc 来供对话框自己调用：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> IntPtr <span class="hljs-title">HookProc</span>(<span class="hljs-params">IntPtr hWnd, <span class="hljs-built_in">int</span> msg, IntPtr wParam, IntPtr lParam</span>)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> IntPtr.Zero;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>接着我们创建 MyColorDialog 和 MyFontDialog，重写 HookProc 返回我们自己的 HookProc，并设置一些参数，让对话框更易使用，以及加入我们的辅助类实例</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyColorDialog</span> : <span class="hljs-title">ColorDialog</span><br>&#123;<br>    <span class="hljs-keyword">private</span> CommonDialogHelper Helper;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyColorDialog</span>()</span><br>    &#123;<br>        AllowFullOpen = <span class="hljs-literal">true</span>;<br>        FullOpen = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DialogResult <span class="hljs-title">ShowDialog</span>(<span class="hljs-params">MyFormBase parent</span>)</span><br>    &#123;<br>        Helper = <span class="hljs-keyword">new</span>(<span class="hljs-keyword">this</span>, parent, HookProc);<br>        <span class="hljs-keyword">return</span> ShowDialog();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> IntPtr <span class="hljs-title">HookProc</span>(<span class="hljs-params">IntPtr hWnd, <span class="hljs-built_in">int</span> msg, IntPtr wparam, IntPtr lparam</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> Helper.HookProc(hWnd, msg, wparam, lparam);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyFontDialog</span> : <span class="hljs-title">FontDialog</span><br>&#123;<br>    <span class="hljs-keyword">private</span> CommonDialogHelper Helper;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyFontDialog</span>()</span><br>    &#123;<br>        AllowVerticalFonts = <span class="hljs-literal">false</span>;<br>        FontMustExist = <span class="hljs-literal">true</span>;<br>        ScriptsOnly = <span class="hljs-literal">true</span>;<br>        ShowEffects = <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DialogResult <span class="hljs-title">ShowDialog</span>(<span class="hljs-params">MyFormBase parent</span>)</span><br>    &#123;<br>        Helper = <span class="hljs-keyword">new</span>(<span class="hljs-keyword">this</span>, parent, HookProc);<br>        <span class="hljs-keyword">return</span> ShowDialog();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> IntPtr <span class="hljs-title">HookProc</span>(<span class="hljs-params">IntPtr hWnd, <span class="hljs-built_in">int</span> msg, IntPtr wparam, IntPtr lparam</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> Helper.HookProc(hWnd, msg, wparam, lparam);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>那我们在 HookProc 里应该写什么呢？这里参考了 System Informer 的<a target="_blank" rel="noopener" href="https://github.com/winsiderss/systeminformer/blob/5475fef970fcbcee128cf88d957280bbcea608d0/SystemInformer/options.c#L3349-L3374">代码</a></p>
<p>我们得知，当对话框创建时，会有一个 WM_INITDIALOG 消息，当对话框设置控件颜色时，会有 WM_CTLCOLOR* 系列消息，此时的返回值表示带有<strong>背景颜色</strong>的画刷。</p>
<p>这里我们就不用 C++ 了，因为 HookProc 在 C# 侧就有实现了，不然整个调用链就太长了。所以我们需要在 C# 里定义这些消息。</p>
<p>消息的具体值怎么找？还记得我们安装的 Windows SDK 吗，我们直接打开 Everything 搜索 winuser.h，打开后查找它们，将这些宏定义转写为 C# 常量字段：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> WM_INITDIALOG = <span class="hljs-number">0x0110</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> WM_CTLCOLORDLG = <span class="hljs-number">0x0136</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> WM_CTLCOLOREDIT = <span class="hljs-number">0x0133</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> WM_CTLCOLORSTATIC = <span class="hljs-number">0x0138</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> WM_CTLCOLORLISTBOX = <span class="hljs-number">0x0134</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> WM_CTLCOLORBTN = <span class="hljs-number">0x0135</span>;<br></code></pre></td></tr></table></figure>

<p>以及声明导入函数，它们是处理 WM_CTLCOLOR* 的四件套</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">DllImport(<span class="hljs-string">&quot;gdi32.dll&quot;</span>)</span>]<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">extern</span> <span class="hljs-built_in">int</span> <span class="hljs-title">SetBkMode</span>(<span class="hljs-params">IntPtr hdc, <span class="hljs-built_in">int</span> mode</span>)</span>;<br><br>[<span class="hljs-meta">DllImport(<span class="hljs-string">&quot;gdi32.dll&quot;</span>)</span>]<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">extern</span> <span class="hljs-built_in">int</span> <span class="hljs-title">SetBkColor</span>(<span class="hljs-params">IntPtr hdc, <span class="hljs-built_in">int</span> color</span>)</span>;<br><br>[<span class="hljs-meta">DllImport(<span class="hljs-string">&quot;gdi32.dll&quot;</span>)</span>]<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">extern</span> <span class="hljs-built_in">int</span> <span class="hljs-title">SetTextColor</span>(<span class="hljs-params">IntPtr hdc, <span class="hljs-built_in">int</span> color</span>)</span>;<br><br>[<span class="hljs-meta">DllImport(<span class="hljs-string">&quot;gdi32.dll&quot;</span>)</span>]<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">extern</span> IntPtr <span class="hljs-title">CreateSolidBrush</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> color</span>)</span>;<br></code></pre></td></tr></table></figure>
<p>由于 CreateSolidBrush 会产生一个句柄，我们需要在对话框关闭的时候清理这些资源：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> WM_DESTROY = <span class="hljs-number">0x0002</span>; <span class="hljs-comment">// 表示对话框被销毁 (关闭)</span><br><br>[<span class="hljs-meta">DllImport(<span class="hljs-string">&quot;gdi32.dll&quot;</span>)</span>]<br>[<span class="hljs-meta">return: MarshalAs(UnmanagedType.Bool)</span>]<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">extern</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">DeleteObject</span>(<span class="hljs-params">IntPtr hObject</span>)</span>;<br></code></pre></td></tr></table></figure>

<p>那怎么处理 WM_INITDIALOG 呢？我们应该在这里完成对控件主题的应用，可是 CommonDialog 并未提供 Controls 集合让我们遍历所有控件。</p>
<p>这就要用到 EnumChildWindows 函数了，以及 GetClassName 让我们判断是什么控件：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">DllImport(<span class="hljs-string">&quot;user32.dll&quot;</span>)</span>]<br>[<span class="hljs-meta">return: MarshalAs(UnmanagedType.Bool)</span>]<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">extern</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">EnumChildWindows</span>(<span class="hljs-params">IntPtr hWndParent, EnumChildProc lpEnumFunc, IntPtr lParam</span>)</span>;<br><br>[<span class="hljs-meta">UnmanagedFunctionPointer(CallingConvention.StdCall)</span>] <span class="hljs-comment">// 表示函数指针：C# 的委托对应的就是 C++ 的函数指针，StdCall</span><br>[<span class="hljs-meta">return: MarshalAs(UnmanagedType.Bool)</span>]<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-built_in">delegate</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">EnumChildProc</span>(<span class="hljs-params">IntPtr hWnd, IntPtr lParam</span>)</span>;<br><br>[<span class="hljs-meta">DllImport(<span class="hljs-string">&quot;user32.dll&quot;</span>, CharSet = CharSet.Unicode)</span>]<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">extern</span> <span class="hljs-built_in">int</span> <span class="hljs-title">GetClassName</span>(<span class="hljs-params">IntPtr hWnd, StringBuilder lpClassName, <span class="hljs-built_in">int</span> nMaxCount</span>)</span>;<br></code></pre></td></tr></table></figure>

<p>现在就可以来完成 HookProc 了，首先缓存一些字段，防止重复计算。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> StringBuilder builder = <span class="hljs-keyword">new</span>(<span class="hljs-number">256</span>); <span class="hljs-comment">// 用于作为 Win32 LPWSTR 动态字符串 的缓冲区，大小一般 256</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> IntPtr hBrush = CreateSolidBrush(BackColor);<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> CanUseDarkTheme = ThemeManager.CanUseDarkTheme;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> ForeColor = ColorTranslator.ToWin32(ThemeManager.DarkFore);<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> BackColor = ColorTranslator.ToWin32(ThemeManager.DarkBack);<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> IntPtr <span class="hljs-title">HookProc</span>(<span class="hljs-params">IntPtr hWnd, <span class="hljs-built_in">int</span> msg, IntPtr wParam, IntPtr lParam</span>)</span><br>&#123;<br>    <span class="hljs-keyword">switch</span> (msg)<br>    &#123;<br>        <span class="hljs-keyword">case</span> WM_INITDIALOG:<br><br>            <span class="hljs-keyword">if</span> (CanUseDarkTheme)<br>            &#123;<br>                ThemeManager.FlushWindow(hWnd);<br><br>                EnumChildWindows(hWnd, (child, _) =&gt; <span class="hljs-comment">// 这就是 Win32 枚举子窗口的用法，类似于 for 循环，只不过在 Win32 中完成，每一次循环都会调用一次这个委托</span><br>                &#123;<br>                    ThemeManager.SetWindowTheme(child, GetThemeName(child), <span class="hljs-literal">null</span>);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 继续枚举，不要停</span><br>                &#125;, IntPtr.Zero);<br>            &#125;<br><br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> WM_CTLCOLORDLG:<br>        <span class="hljs-keyword">case</span> WM_CTLCOLOREDIT:<br>        <span class="hljs-keyword">case</span> WM_CTLCOLORSTATIC:<br>        <span class="hljs-keyword">case</span> WM_CTLCOLORLISTBOX:<br>        <span class="hljs-keyword">case</span> WM_CTLCOLORBTN:<br><br>            <span class="hljs-keyword">if</span> (CanUseDarkTheme)<br>            &#123;<br>                SetBkMode(wParam, <span class="hljs-number">1</span>);<br>                SetTextColor(wParam, ForeColor);<br>                SetBkColor(wParam, BackColor);<br>                <span class="hljs-keyword">return</span> hBrush;<br>            &#125;<br><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> IntPtr.Zero;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> <span class="hljs-title">GetThemeName</span>(<span class="hljs-params">IntPtr child</span>) <span class="hljs-comment">// 判断控件类型以及返回主题名称</span></span><br>&#123;<br>    GetClassName(child, builder, <span class="hljs-number">256</span>);<br>    <span class="hljs-keyword">var</span> className = builder.ToString();<br><br>    <span class="hljs-keyword">if</span> (className == <span class="hljs-string">&quot;ComboBox&quot;</span> || className == <span class="hljs-string">&quot;Edit&quot;</span>) <span class="hljs-comment">// 表示 ComboBox 和 TextBox</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;DarkMode_CFD&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;DarkMode_Explorer&quot;</span>; <span class="hljs-comment">// 其他就默认 Explorer 主题</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p class="note note-info"><strong>字符串的比较</strong><br>使用 <code>==</code> 运算符比较字符串是较为高效的，相当于调用 <code>a.Equals(b, StringComparison.Ordinal)</code>，即通过序号来比较字符串。要注意的是该比较方式是要区分大小写的，不过在这里也不用担心会匹配不到控件，因为像 CommonDialog 这种标准 Win32 对话框，其中控件的类名也都是标准的。</p>

<p>看看效果：</p>
<p><img src="/archive-imgs/38/42-dark-colordialog.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/archive-imgs/38/43-dark-fontdialog-1.png" srcset="/img/loading.gif" lazyload></p>
<p>一气呵成，简直不要太爽。</p>
<p>但，对于 FontDialog，瑕疵貌似有点多。特别是那几个发白的控件，目前说实话我也没有办法解决，因为它们都是已经自绘过的了，这就好比修电脑的师傅喜欢修一手的一样。当控件已经自绘之后，再次自绘，要么工作量巨大，要么也不会有好结果，那这个问题我们就放在这，以后有思路再来搞一下。</p>
<p>我们还是先搞一下那个 GroupBox，因为它看起来还能抢救一下，就显示字体预览的那个，可以看到它标题的文字是没有适应深色主题的。</p>
<p>是不是有点似曾相识？针对 GroupBox 标题不适应主题的情况我们前面是不是分析过？也就是重写 OnPaint 自己画边框和文字就解决的。但有个大前提，得在托管环境下。然而这个对话框是 Win32 的，属于非托管环境，应该怎么办呢？</p>
<p>想想我们当时是不是创建了 MyGroupBox 来重写 OnPaint？</p>
<p>也就是说在这里，我们需要对它进行子类化，不能在 HookProc 里直接处理 WM_PAINT，那是发给对话框的，不是这个 GroupBox。</p>
<p>那我们怎么用 C# 做子类化，上面基础知识里也说过了。没错！用 NativeWindow 类。我们在 CommonDialogHelper 里写一个私有的嵌套类，命名为 GroupBoxNativeWindow，并让它继承自 NativeWindow，再给它个构造函数传入 GroupBox 句柄，方便我们一创建实例就开始运作。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CommonDialogHelper</span>(<span class="hljs-params">CommonDialog dialog, MyFormBase parent, HOOKPROC DefHookProc</span>)</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GroupBoxNativeWindow</span> : <span class="hljs-title">NativeWindow</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GroupBoxNativeWindow</span>(<span class="hljs-params">IntPtr hGroupBox</span>)</span><br>        &#123;<br>            AssignHandle(hGroupBox); <span class="hljs-comment">// 这是使用 NativeWindow 子类化的开始，我们需要提供一个 HWND</span><br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WndProc</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> Message m</span>)</span><br>        &#123;<br>            <span class="hljs-comment">// 重写 WndProc，我们就相当于进入了子类化过程</span><br><br>            <span class="hljs-keyword">base</span>.WndProc(<span class="hljs-keyword">ref</span> m);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>由于我发现在非托管环境按之前的思路完全重绘 GroupBox 会导致闪烁，于是我想到一个很巧妙的方法：</p>
<p>我们先让它自己画，也就是保留默认样式，接着我们就只需要在原来标题文字的地方再画一个一模一样的文字将原有的盖住，不就行了？</p>
<p>大致步骤就是：</p>
<ul>
<li>拦截 WM_PAINT，但先让它自己画 -&gt; 获取标题以及字体 -&gt; 获取 GroupBox 标题的坐标和大小 -&gt; 画文字</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">StructLayout(LayoutKind.Sequential)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> RECT <span class="hljs-comment">// 这个结构写在 CommonDialogHelper 外面</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Left;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Top;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Right;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Bottom;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">Rectangle</span>(<span class="hljs-params">RECT r</span>)</span><br><span class="hljs-function">    <span class="hljs-comment">// 添加隐式转换为 Rectangle</span></span><br>    &#123;<br>        <span class="hljs-keyword">return</span> Rectangle.FromLTRB(r.Left, r.Top, r.Right, r.Bottom);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CommonDialogHelper</span>(<span class="hljs-params">CommonDialog dialog, MyFormBase parent, HOOKPROC DefHookProc</span>)</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GroupBoxNativeWindow</span> : <span class="hljs-title">NativeWindow</span><br>    &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> WM_PAINT = <span class="hljs-number">0x000F</span>;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> WM_GETFONT = <span class="hljs-number">0x0031</span>;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> Handled; <span class="hljs-comment">// 为了防止多次触发重绘导致文字重影，所以使用一个标志来表示是否已经画过一次了</span><br><br>        <span class="hljs-comment">// ...</span><br><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WndProc</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> Message m</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (m.Msg == WM_PAINT)<br>            &#123;<br>                <span class="hljs-keyword">base</span>.WndProc(<span class="hljs-keyword">ref</span> m); <span class="hljs-comment">// 先让它自己画</span><br><br>                <span class="hljs-keyword">if</span> (!Handled) <span class="hljs-comment">// 确保我们只画一次</span><br>                &#123;<br>                    IntPtr hdc;<br>                    IntPtr hWnd = Handle;<br><br>                    <span class="hljs-keyword">if</span> ((hdc = GetWindowDC(hWnd)) != IntPtr.Zero) <span class="hljs-comment">// 拿到 DC，用于创建 Graphics</span><br>                    &#123;<br>                        <span class="hljs-keyword">using</span> <span class="hljs-keyword">var</span> g = Graphics.FromHdc(hdc);<br>                        <span class="hljs-keyword">using</span> <span class="hljs-keyword">var</span> font = Font.FromHfont(SendMessage(hWnd, WM_GETFONT, IntPtr.Zero, IntPtr.Zero));<br>                        <span class="hljs-comment">// 获取字体</span><br><br>                        <span class="hljs-keyword">using</span> <span class="hljs-keyword">var</span> brush = <span class="hljs-keyword">new</span> SolidBrush(ThemeManager.DarkFore); <span class="hljs-comment">// 创建画刷</span><br><br>                        GetClientRect(hWnd, <span class="hljs-keyword">out</span> RECT rc);<br>                        rc.Left += <span class="hljs-number">6</span>; <span class="hljs-comment">// 由于我们是覆盖原标题，实测偏移 6px 最佳，而不是之前我们自绘托管 GroupBox 的 4px</span><br>                        Rectangle rect = rc; <span class="hljs-comment">// 触发隐式转换 RECT 为 Rectangle</span><br>                        <span class="hljs-keyword">var</span> sb = <span class="hljs-keyword">new</span> StringBuilder(GetWindowTextLength(hWnd) + <span class="hljs-number">1</span>); <span class="hljs-comment">// 创建 Win32 LPWSTR 动态字符串的缓冲区</span><br>                        GetWindowText(hWnd, sb, sb.Capacity); <span class="hljs-comment">// 获取 GroupBox 的标题，写入缓冲区</span><br>                        g.DrawString(sb.ToString(), font, brush, rect); <span class="hljs-comment">// ToString 拿出标题，然后画出来</span><br>                        ReleaseDC(hWnd, hdc); <span class="hljs-comment">// 释放 DC 占用的资源</span><br>                        Handled = <span class="hljs-literal">true</span>;<br>                    &#125;<br>                &#125;<br><br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">base</span>.WndProc(<span class="hljs-keyword">ref</span> m);<br>        &#125;<br><br>        [<span class="hljs-meta">DllImport(<span class="hljs-string">&quot;user32.dll&quot;</span>, CharSet = CharSet.Unicode)</span>]<br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">extern</span> <span class="hljs-built_in">int</span> <span class="hljs-title">GetWindowText</span>(<span class="hljs-params">IntPtr hWnd, StringBuilder lpString, <span class="hljs-built_in">int</span> nMaxCount</span>)</span>;<br><br>        [<span class="hljs-meta">DllImport(<span class="hljs-string">&quot;user32.dll&quot;</span>, CharSet = CharSet.Unicode)</span>]<br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">extern</span> <span class="hljs-built_in">int</span> <span class="hljs-title">GetWindowTextLength</span>(<span class="hljs-params">IntPtr hWnd</span>)</span>; <span class="hljs-comment">// 获取窗口标题的字符串的长度</span><br><br>        [<span class="hljs-meta">DllImport(<span class="hljs-string">&quot;user32.dll&quot;</span>)</span>]<br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">extern</span> <span class="hljs-built_in">int</span> <span class="hljs-title">ReleaseDC</span>(<span class="hljs-params">IntPtr hWnd, IntPtr hDC</span>)</span>;<br><br>        [<span class="hljs-meta">DllImport(<span class="hljs-string">&quot;user32.dll&quot;</span>)</span>]<br>        [<span class="hljs-meta">return: MarshalAs(UnmanagedType.Bool)</span>]<br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">extern</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">GetClientRect</span>(<span class="hljs-params">IntPtr hWnd, <span class="hljs-keyword">out</span> RECT lpRect</span>)</span>; <span class="hljs-comment">// 获取窗口的 ClientRectangle</span><br><br>        [<span class="hljs-meta">DllImport(<span class="hljs-string">&quot;user32.dll&quot;</span>)</span>]<br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">extern</span> IntPtr <span class="hljs-title">GetWindowDC</span>(<span class="hljs-params">IntPtr hWnd</span>)</span>; <span class="hljs-comment">// 获取窗口的设备上下文，通常用于绘图</span><br><br>        [<span class="hljs-meta">DllImport(<span class="hljs-string">&quot;user32.dll&quot;</span>)</span>]<br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">extern</span> IntPtr <span class="hljs-title">SendMessage</span>(<span class="hljs-params">IntPtr hWnd, <span class="hljs-built_in">int</span> msg, IntPtr wParam, IntPtr lParam</span>)</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p class="note note-info"><strong>[StructLayout(LayoutKind.Sequential)] 是什么？</strong><br>该特性常见于用于 Interop 的 struct 类型上，有助于 CLR 从非托管环境中将对象封送到托管环境并映射为具体类型，它只作用于 struct 中的字段，也就是为什么我们在里面写了一个运算符重载也不会出错，因为 CLR 会自动忽略除字段以外的成员。甚至你还会发现有的开发者会直接用自动属性代替，这是因为自动属性本质上就是字段+方法，CLR 也能识别到。由于 struct 本身在内存中的布局是连续的 (Sequential)，并且是无明确类型的，也就是说我们不一定非得用 RECT 这个名称，其他也可以，只要确保字段的顺序与 Win32 定义的一致就行了。</p>

<p>现在我们的子类化已经完成了，就差获取那个 GroupBox 的句柄了。这貌似又有点挑战，怎么获取？</p>
<p>你可能会想到 FindWindow(Ex) 函数，指定窗口标题来获取 HWND，这在逻辑上说得过去。但是你想过 i18n 吗？就比如我使用的英文版系统中，这个 GroupBox 的标题是 Sample，中文系统中是 示例，那你该怎么办？你可能想，那我们先获取标题，再获取句柄不就行了？注意，我们要获取 GroupBox 的标题本来就要先获取它句柄。</p>
<p>所以你发现没有，以上这条路是行不通的，那怎么办？文档！</p>
<p>打开搜索引擎，搜索 <code>win32 get dialog control handle</code>，第一个就是：</p>
<p><img src="/archive-imgs/38/44-google-getdlgitem.png" srcset="/img/loading.gif" lazyload></p>
<p>所以说呀，关键词大法+英文检索 真的能在很多时候秒搜出你想要的。</p>
<p>直接一个导入</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">DllImport(<span class="hljs-string">&quot;user32.dll&quot;</span>)</span>]<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">extern</span> IntPtr <span class="hljs-title">GetDlgItem</span>(<span class="hljs-params">IntPtr hDlg, <span class="hljs-built_in">int</span> nIDDlgItem</span>)</span>;<br></code></pre></td></tr></table></figure>

<p>但这又有一个问题，这个函数的原理是指定对话框的 HWND 和控件的 ID 就能获取到控件 HWND，前者我们可以获取得到，那后者呢？可恶的是文档里居然也没写哪里有 ID。</p>
<p>通过一些手段，我们得知，在 Windows SDK 中，包含了 FontDialog 的对话框模板 (Font.Dlg，可类比 WinForms 设计器生成的代码) 以及所有的 Common Dialogs 的控件的 ID (dlgs.h)。那我们直接 Everything 搜索出来打开就行了。</p>
<p>先打开 Font.Dlg 看看这个 GroupBox 的 ID 是什么：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">GROUPBOX        <span class="hljs-string">&quot;Sample&quot;</span>, grp2, <span class="hljs-number">110</span>, <span class="hljs-number">97</span>, <span class="hljs-number">116</span>, <span class="hljs-number">43</span>, WS_GROUP <br><span class="hljs-comment">// 根据类型，以及设置的文本我们就能确定该控件</span><br></code></pre></td></tr></table></figure>
<p>好的，它的 ID 是 grp2，那么这个 ID 的具体值是什么？接着打开 dlgs.h，直接 Ctrl+F 通缉 grp2</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> grp2        0x0431</span><br></code></pre></td></tr></table></figure>
<p>看到没，这不就出来了。</p>
<p>那我们现在就可以在 WM_INITDIALOG 里面对它进行子类化了，但得先确保初始化 CommonDialogHelper 的是 MyFontDialog (其实也可以不用，因为控件 ID 是唯一的)</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> IntPtr <span class="hljs-title">HookProc</span>(<span class="hljs-params">IntPtr hWnd, <span class="hljs-built_in">int</span> msg, IntPtr wParam, IntPtr lParam</span>)</span><br>&#123;<br>    <span class="hljs-keyword">switch</span> (msg)<br>    &#123;<br>        <span class="hljs-keyword">case</span> WM_INITDIALOG:<br><br>            <span class="hljs-keyword">if</span> (CanUseDarkTheme)<br>            &#123;<br>                <span class="hljs-comment">// ...</span><br><br>                <span class="hljs-keyword">if</span> (dialog <span class="hljs-keyword">is</span> MyFontDialog) <span class="hljs-comment">// 验证当前对话框是不是 MyFontDialog</span><br>                &#123;<br>                    IntPtr hCtrl = GetDlgItem(hWnd, <span class="hljs-number">0x0431</span>);<br><br>                    <span class="hljs-keyword">if</span> (hCtrl != IntPtr.Zero) <span class="hljs-comment">// 最后一道保险，确保已获取到 HWND</span><br>                    &#123;<br>                        <span class="hljs-keyword">new</span> GroupBoxNativeWindow(hCtrl); <span class="hljs-comment">// 启动子类化</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> IntPtr.Zero;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>看看效果</p>
<p><img src="/archive-imgs/38/45-dark-fontdialog-2.png" srcset="/img/loading.gif" lazyload></p>
<p>非常完美 (除了那几个白色的实在没法)</p>
<p>但还没完，还记得我们在重写这两种对话框的 HookProc 吗，我们直接返回了 Helper 的 HookProc，那默认的 HookProc 呢？</p>
<p>所以我们还要补全 switch 分支，特别是 WM_COMMAND，会影响一些按钮的触发等，除此之外也要在 WM_INITDIALOG 为系统默认控件提供焦点，这是一种规范，此时只需要返回 TRUE 就行，也就是 new IntPtr(1)。</p>
<p class="note note-info">Win32 的<code>BOOL</code>类型本质就是<code>int</code>，0 表示 <code>FALSE</code>，其他值 (一般用 1) 表示<code>TRUE</code>。我们这里返回<code>TRUE</code>就相当于返回 1，再用 IntPtr 封装一下，就变成了<code>new IntPtr(1)</code></p>

<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> WM_COMMAND = <span class="hljs-number">0x0111</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> IntPtr <span class="hljs-title">HookProc</span>(<span class="hljs-params">IntPtr hWnd, <span class="hljs-built_in">int</span> msg, IntPtr wParam, IntPtr lParam</span>)</span><br>&#123;<br>    <span class="hljs-keyword">switch</span> (msg)<br>    &#123;<br>        <span class="hljs-keyword">case</span> WM_INITDIALOG:<br>            <span class="hljs-comment">// ...</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">case</span> WM_CTLCOLORDLG:<br>        <span class="hljs-keyword">case</span> WM_CTLCOLOREDIT:<br>        <span class="hljs-keyword">case</span> WM_CTLCOLORSTATIC:<br>        <span class="hljs-keyword">case</span> WM_CTLCOLORLISTBOX:<br>        <span class="hljs-keyword">case</span> WM_CTLCOLORBTN:<br>            <span class="hljs-comment">// ...</span><br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> WM_COMMAND:<br>            <span class="hljs-keyword">return</span> DefHookProc(hWnd, WM_COMMAND, wParam, lParam);<br>            <span class="hljs-comment">// 这是实现对话框一些其他功能的关键所在，这里调用默认的 HookProc 处理</span><br>        <span class="hljs-keyword">case</span> WM_DESTROY:<br>            DeleteObject(hBrush); <span class="hljs-comment">// 别忘了删除那个画刷占用的资源</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> IntPtr.Zero;<br>&#125;<br><br>[<span class="hljs-meta">DllImport(<span class="hljs-string">&quot;user32.dll&quot;</span>)</span>]<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">extern</span> IntPtr <span class="hljs-title">SetFocus</span>(<span class="hljs-params">IntPtr hWnd</span>)</span>;<br></code></pre></td></tr></table></figure>
<p>看看效果</p>
<p><img src="/archive-imgs/38/46-helper-soe.png" srcset="/img/loading.gif" lazyload></p>
<p>诶诶诶，怎么堆栈溢出了？</p>
<p>这个异常是我们在补全 switch 之后抛出的，虽然 Visual Studio 把错误定位在 CanUseDarkTheme 上，但我觉得不是这个问题，因为在这之前都是可以的。</p>
<p>那就从我们添加的内容中一个个排查：</p>
<ul>
<li><code>return new IntPtr(1)</code> 可能引发该异常吗？不会。</li>
<li><code>DefHookProc(hWnd, WM_COMMAND, wParam, lParam)</code> 呢？貌似也不会</li>
<li><code>DeleteObject(hBrush)</code> 就更不会了</li>
</ul>
<p>那问题肯定就出在 DefHookProc 这个参数上了，它是我们 Helper 的第二个参数，用来封装默认 HookProc 的。</p>
<p>来看看我们是怎么初始化 Helper 的，在 MyFontDialog 和 MyColorDialog 里，我们都用到了同样的代码：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> DialogResult <span class="hljs-title">ShowDialog</span>(<span class="hljs-params">MyFormBase parent</span>)</span><br>&#123;<br>    Helper = <span class="hljs-keyword">new</span>(<span class="hljs-keyword">this</span>, parent, HookProc);<br>    <span class="hljs-keyword">return</span> ShowDialog();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我说问题就在这里，你发现了吗？</p>
<p>没有？那我请问我们传入的 HookProc 是默认的 HookProc 吗？</p>
<p>肯定不是啊，这里隐式包含了 this 关键字，也就是说我们把我们自己重写过的 HookProc 给传进去了，它返回的就是 Helper 的 HookProc。当 Helper 的 HookProc 走到 WM_COMMAND 时，就会来调用我们重写的 HookProc，然后又进到 Helper 里的 HookProc，如此循环往复…</p>
<p>是不是这个就是导致堆栈溢出的罪魁祸首？对嘛，两个方法，你调用我，我调用你，那咱谁也别想跳出去了。那正确的写法是什么？—— 加上 base 关键字</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> DialogResult <span class="hljs-title">ShowDialog</span>(<span class="hljs-params">MyFormBase parent</span>)</span><br>&#123;<br>    Helper = <span class="hljs-keyword">new</span>(<span class="hljs-keyword">this</span>, parent, <span class="hljs-keyword">base</span>.HookProc);<br>    <span class="hljs-keyword">return</span> ShowDialog();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>再来运行看看，非常好，没错了。</p>
<p>你以为这就完了吗？还记得我们在 ShowDialog&#x2F;CommonDialogHelper 传入的 parent 参数吗？还没用呢，我们计划让对话框显示在父窗体的中心。而默认的位置是屏幕中心，反正我觉得不河里。当然由于我们完全接管了 WM_INITDIALOG，所以它们现在也没在屏幕中心，而是系统随机决定的位置。</p>
<p>要实现这个功能，其实也不复杂。首先声明导入函数，用于获取对话框位置和大小，以及移动对话框。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">DllImport(<span class="hljs-string">&quot;user32.dll&quot;</span>)</span>]<br>[<span class="hljs-meta">return: MarshalAs(UnmanagedType.Bool)</span>]<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">extern</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">GetWindowRect</span>(<span class="hljs-params">IntPtr hWnd, <span class="hljs-keyword">out</span> RECT lpRect</span>)</span>;<br><br>[<span class="hljs-meta">DllImport(<span class="hljs-string">&quot;user32.dll&quot;</span>)</span>]<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MoveWindow</span>(<span class="hljs-params">IntPtr hWnd, <span class="hljs-built_in">int</span> X, <span class="hljs-built_in">int</span> Y, <span class="hljs-built_in">int</span> nWidth, <span class="hljs-built_in">int</span> nHeight, [MarshalAs(UnmanagedType.Bool</span>)] <span class="hljs-built_in">bool</span> bRepaint)</span>;<br></code></pre></td></tr></table></figure>

<p>进入 WM_INITDIALOG 分支，在所有代码之后添加：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">case</span> WM_INITDIALOG:<br>    <span class="hljs-comment">// ...</span><br>    GetWindowRect(hWnd, <span class="hljs-keyword">out</span> RECT r);<br>    CenterDialog(hWnd, r); <span class="hljs-comment">// 表示居中对话框，r 参数在这里触发了隐式转换为 Rectangle</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>

<p>由于涉及到很多计算，我们应该将过程单独放到一个方法里，不然直接写太难看了。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CenterDialog</span>(<span class="hljs-params">IntPtr hWnd, Rectangle rect</span>)</span><br>&#123;<br>    <span class="hljs-keyword">var</span> validArea = Screen.GetWorkingArea(parent); <span class="hljs-comment">// 获取父窗体所在屏幕的工作区 (除任务栏剩下的区域)</span><br><br>    <span class="hljs-keyword">var</span> w = rect.Width;<br>    <span class="hljs-keyword">var</span> h = rect.Height;<br>    <span class="hljs-keyword">var</span> x = parent.Left + (parent.Width / <span class="hljs-number">2</span>) - (w / <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">var</span> y = parent.Top + (parent.Height / <span class="hljs-number">2</span>) - (h / <span class="hljs-number">2</span>); <span class="hljs-comment">// 这4行用于计算居中后对话框的坐标</span><br><br>    <span class="hljs-keyword">var</span> l = x;<br>    <span class="hljs-keyword">var</span> t = y;<br>    <span class="hljs-keyword">var</span> r = x + w;<br>    <span class="hljs-keyword">var</span> b = y + h; <br>    <span class="hljs-keyword">if</span> (l &lt; validArea.X) x = validArea.X;<br>    <span class="hljs-keyword">if</span> (t &lt; validArea.Y) y = validArea.Y;<br>    <span class="hljs-keyword">if</span> (r &gt; validArea.Right) x = validArea.Right - w;<br>    <span class="hljs-keyword">if</span> (b &gt; validArea.Bottom) y = validArea.Bottom - h; <span class="hljs-comment">// 这4行防止对话框超出屏幕边缘</span><br><br>    MoveWindow(hWnd, x, y, w, h, <span class="hljs-literal">false</span>); <span class="hljs-comment">// 移动对话框</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行即可，肯定是没问题的，这里就不放截图了，截了也看不出来。</p>
<p>注意我们在调用 ShowDialog 时要传入当前窗体 (继承自 MyFormBase) 的实例，也就是 <code>this</code>：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">new</span> MyFontDialog().ShowDialog(<span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">new</span> MyColorDialog().ShowDialog(<span class="hljs-keyword">this</span>);<br></code></pre></td></tr></table></figure>

<p>其实我们还漏掉了一个功能，那就是 .NET 封装的 FontDialog 还额外增加了不显示颜色选项的功能 (ShowColor)，开启后 FontDialog 将不显示设置颜色的选项。</p>
<p>与之类似的是 Win32 提供的不显示效果的功能 (ShowEffects)，这个功能开启后不会显示下划线、删除线、以及颜色这些选项。</p>
<p>那为什么我们的 FontDialog 看似没有问题呢？因为我们将 ShowEffects 设置为了 false，这会隐藏所有相关选项，所以看起来没有问题。一旦我们开启 ShowEffects 然后关闭 ShowColor，就可以发现所有的选项都出来了，颜色相关的根本就没有被隐藏。</p>
<p>因为 ShowColor 是 WinForms 自行在 WM_INITDIALOG 里处理的，我们完全接管了 WM_INITDIALOG，所以就没被隐藏了；而 ShowEffects 是 Win32 提供的，所以始终有效。</p>
<p>我们先来看看 WinForms 是怎样处理的，打开 WinForms <a target="_blank" rel="noopener" href="https://github.com/dotnet/winforms/blob/770b5a9825d68063ba889fc6bb89c8c0a69566ac/src/System.Windows.Forms/System/Windows/Forms/Dialogs/CommonDialogs/FontDialog.cs#L343-L352">源码</a></p>
<p><img src="/../archive-imgs/38/47-wf-fntdlg-hook-initdlg.png" srcset="/img/loading.gif" lazyload></p>
<p>看到了吧，WinForms 也是通过 GetDlgItem 获取相关控件的句柄，然后设置 SW_HIDE 将它们隐藏。也就是说我们也需要自己写这一部分的代码</p>
<p>可能有的朋友在想，那我们为什么不在这里调用 DefHookProc 让它自己删除呢？</p>
<p>看到上图的 HookProc 的 switch 语句外面是什么了吗，它调用了基类 (CommonDialog) 的 HookProc，那我们再来看看基类在 WM_INITDIALOG 时又在干什么。<a target="_blank" rel="noopener" href="https://github.com/dotnet/winforms/blob/770b5a9825d68063ba889fc6bb89c8c0a69566ac/src/System.Windows.Forms/System/Windows/Forms/Dialogs/CommonDialogs/CommonDialog.cs#L66-L74">源码</a></p>
<p><img src="/../archive-imgs/38/48-commdlg-hook-initdlg.png" srcset="/img/loading.gif" lazyload></p>
<p>Move！To！ScreenCenter！把对话框移动到屏幕中心，但是我们已经实现了移动到父窗体中心，那我们就不能调用 DefHookProc 了，因为会让对话框移动两次。所以，自己写更实在：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> SW_HIDE = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> IntPtr <span class="hljs-title">HookProc</span>(<span class="hljs-params">IntPtr hWnd, <span class="hljs-built_in">int</span> msg, IntPtr wParam, IntPtr lParam</span>)</span><br>&#123;<br>    <span class="hljs-keyword">switch</span> (msg)<br>    &#123;<br>        <span class="hljs-keyword">case</span> WM_INITDIALOG:<br><br>            <span class="hljs-keyword">if</span> (CanUseDarkTheme)<br>            &#123;<br>                <span class="hljs-comment">// ...</span><br><br>                <span class="hljs-keyword">if</span> (dialog <span class="hljs-keyword">is</span> MyFontDialog f) <span class="hljs-comment">// 验证当前对话框是不是 MyFontDialog</span><br>                &#123;<br>                    <span class="hljs-comment">// ...</span><br><br>                    <span class="hljs-keyword">if</span> (!f.ShowColor)<br>                    &#123;<br>                        <span class="hljs-keyword">if</span> ((hCtrl = GetDlgItem(hWnd, <span class="hljs-number">0x0473</span>)) != IntPtr.Zero)<br>                        &#123;<br>                            ShowWindow(hCtrl, SW_HIDE);<br>                        &#125;<br><br>                        <span class="hljs-keyword">if</span> ((hCtrl = GetDlgItem(hWnd, <span class="hljs-number">0x0443</span>)) != IntPtr.Zero)<br>                        &#123;<br>                            ShowWindow(hCtrl, SW_HIDE);<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-comment">// ...</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> IntPtr.Zero;<br>&#125;<br><br>[<span class="hljs-meta">DllImport(<span class="hljs-string">&quot;user32.dll&quot;</span>)</span>]<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">extern</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">ShowWindow</span>(<span class="hljs-params">IntPtr hWnd, <span class="hljs-built_in">int</span> nCmdShow</span>)</span>;<br></code></pre></td></tr></table></figure>

<p>运行看看，完全没问题。</p>
<p class="note note-warning"><strong>虽然我们完善了 FontDialog，但还是建议不要在 FontDialog 里挑选颜色</strong><br>1. 单一职责：FontDialog 还是挑选字体比较好，挑选颜色用 ColorDialog，可选颜色也更丰富<br>2. 这部分的深色主题还未完成，也不打算搞了，反正我们也不会用到。</p>

<p>至此，我们的深色主题计划就大功告成了，快去试试吧。</p>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul>
<li>PlainCEETimer<br><a target="_blank" rel="noopener" href="https://github.com/WangHaonie/PlainCEETimer">https://github.com/WangHaonie/PlainCEETimer</a></li>
<li>Win32 Dark Mode<br><a target="_blank" rel="noopener" href="https://gist.github.com/rounk-ctrl/b04e5622e30e0d62956870d5c22b7017">https://gist.github.com/rounk-ctrl/b04e5622e30e0d62956870d5c22b7017</a></li>
<li>ysc3839&#x2F;win32-darkmode: Example application shows how to use undocumented dark mode API introduced in Windows 10 1809.<br><a target="_blank" rel="noopener" href="https://github.com/ysc3839/win32-darkmode">https://github.com/ysc3839/win32-darkmode</a></li>
<li>BlueMystical&#x2F;Dark-Mode-Forms: Apply Dark Mode to all Controls in a Form [WinForms]<br><a target="_blank" rel="noopener" href="https://github.com/BlueMystical/Dark-Mode-Forms">https://github.com/BlueMystical/Dark-Mode-Forms</a></li>
<li>winsiderss&#x2F;systeminformer: A free, powerful, multi-purpose tool that …<br><a target="_blank" rel="noopener" href="https://github.com/winsiderss/systeminformer">https://github.com/winsiderss/systeminformer</a></li>
<li>How to create a Custom group box control with border color - Vb.net @mikecodz2821 - YouTube<br><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=_7NwVqfNU1g">https://www.youtube.com/watch?v=_7NwVqfNU1g</a></li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Windows/" class="print-no-link">#Windows</a>
      
        <a href="/tags/CSharp/" class="print-no-link">#CSharp</a>
      
        <a href="/tags/WinForms/" class="print-no-link">#WinForms</a>
      
        <a href="/tags/%E9%95%BF%E7%AF%87/" class="print-no-link">#长篇</a>
      
        <a href="/tags/Cpp/" class="print-no-link">#Cpp</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>从零开始让你的 WinForms 应用程序也用上原生深色主题</div>
      <div>https://wanghaonie.github.io/posts/00d12b183e8c/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>WangHaonie</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025-07-23 08:31:03</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>更新于</div>
          <div>2025-07-26 10:55:31</div>
        </div>
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="NC - 非商业性使用">
                    <i class="iconfont icon-nc"></i>
                  </span>
                </a>
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="SA - 相同方式共享">
                    <i class="iconfont icon-sa"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/posts/921e4b4f8e14/" title="【COM API】基础知识与使用方法">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">【COM API】基础知识与使用方法</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/posts/d1afa7a5de7f/" title="【C#】for 和 foreach 循环的选择">
                        <span class="hidden-mobile">【C#】for 和 foreach 循环的选择</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
    <div id="giscus" class="giscus"></div>
    <script type="text/javascript">
      Fluid.utils.loadComments('#giscus', function() {
        var options = {"repo":"WangHaonie/wanghaonie.github.io","repo-id":"MDEwOlJlcG9zaXRvcnkzODM3MTI4NzU=","category":"General","category-id":"DIC_kwDOFt7-a84CtZ7y","theme-light":"light","theme-dark":"dark","mapping":"pathname","reactions-enabled":1,"emit-metadata":0,"input-position":"top","lang":"zh-CN"};
        var attributes = {};
        for (let option in options) {
          if (!option.startsWith('theme-')) {
            var key = option.startsWith('data-') ? option : 'data-' + option;
            attributes[key] = options[option];
          }
        }
        var light = 'light';
        var dark = 'dark';
        window.GiscusThemeLight = light;
        window.GiscusThemeDark = dark;
        attributes['data-theme'] = document.documentElement.getAttribute('data-user-color-scheme') === 'dark' ? dark : light;
        for (let attribute in attributes) {
          var value = attributes[attribute];
          if (value === undefined || value === null || value === '') {
            delete attributes[attribute];
          }
        }
        var s = document.createElement('script');
        s.setAttribute('src', 'https://giscus.app/client.js');
        s.setAttribute('crossorigin', 'anonymous');
        for (let attribute in attributes) {
          s.setAttribute(attribute, attributes[attribute]);
        }
        var ss = document.getElementsByTagName('script');
        var e = ss.length > 0 ? ss[ss.length - 1] : document.head || document.documentElement;
        e.parentNode.insertBefore(s, e.nextSibling);
      });
    </script>
    <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span> Hexo </span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span> Fluid </span></a><br> <div><a> <span id="site-runtime">正在加载网站运行时间，请稍候...</span> <script src="/js/runtime.js"></script> </a></div>
    </div>
  
  
  
    <!-- 备案信息 ICP for China -->
    <div class="beian">
  <span>
    <a rel="nofollow noopener">
      Copyright © 2023-2025 WangHaonie
    </a>
  </span>
  
    
      <span>
        <a
          href="https://icp.gov.moe/?keyword=20229939"
          rel="nofollow noopener"
          class="beian-police"
          target="_blank"
        >
          
            <span style="visibility: hidden; width: 0">|</span>
            <img src="/img/icon_moeicp.png" srcset="/img/loading.gif" lazyload/>
          
          <span>萌ICP备20229939号</span>
        </a>
      </span>
    
  
</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>





  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>




  
<script src="/js/customstyles.js"></script>
<script src="/js/subsiteredirect.js"></script>
<script src="/js/bgribbon.js"></script>
<script src="/js/curfireworks.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
